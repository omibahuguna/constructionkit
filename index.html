<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Narrative Construction Kit</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
/* ─────────────────────────────────────────
   DESIGN TOKENS
───────────────────────────────────────── */
:root {
  /* Terminal green palette */
  --bg:         #000000;
  --surface:    #030903;
  --surface-2:  #061206;
  --card:       #061206;
  --border:     rgba(51,187,51,0.22);
  --border-2:   rgba(51,187,51,0.55);
  --fg:         #3bbb3b;
  --fg-2:       #267026;
  --fg-3:       rgba(59,187,59,0.38);
  --pill-bg:    #061206;
  --accent:     #55ff55;
  --track-bg:   #030903;
  --ruler-bg:   #000000;
  --text-red:   #ff3333;

  /* Typography */
  --font-display: 'IBM Plex Mono', monospace;
  --font-body:    'IBM Plex Mono', monospace;
  --text-2xs:  10px;
  --text-xs:   11px;
  --text-sm:   12px;
  --text-base: 13px;
  --text-md:   14px;
  --text-lg:   16px;
  --text-xl:   20px;
  --text-2xl:  24px;

  /* Spacing (4px grid) */
  --sp-1: 4px;
  --sp-2: 8px;
  --sp-3: 12px;
  --sp-4: 16px;
  --sp-5: 20px;
  --sp-6: 24px;

  /* Touch targets */
  --target-sm:  32px;
  --target-md:  40px;
  --target-lg:  44px;
  --target-xl:  52px;

  /* Track */
  --track-h:    48px;
  --clip-top:   5px;
  --clip-h:     38px;
}

/* ─────────────────────────────────────────
   RESET + BASE
───────────────────────────────────────── */
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; overflow: hidden; background: var(--bg); font-family: var(--font-body); color: var(--fg); font-size: var(--text-base); -webkit-font-smoothing: antialiased; }

button { font-family: inherit; }
input  { font-family: inherit; }

/* ─────────────────────────────────────────
   INTRO OVERLAY
───────────────────────────────────────── */
#intro-overlay {
  position: fixed; inset: 0;
  background: #080910; z-index: 9999;
  display: none; /* temporarily disabled — re-enable by changing to flex */
  flex-direction: column;
  align-items: center; justify-content: center;
  gap: var(--sp-5);
  animation: fadeIn 1.4s ease forwards;
}
@keyframes fadeIn  { from { opacity: 0; } to { opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
@keyframes slideUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

#intro-overlay.dismissing { animation: fadeOut 0.5s ease forwards; pointer-events: none; }

.intro-heading {
  font-family: var(--font-display);
  font-size: clamp(32px, 7vw, 84px);
  font-weight: 900;
  letter-spacing: 0.05em;
  color: var(--fg);
  text-align: center; line-height: 1.1;
  animation: slideUp 1.2s 0.5s both;
}
.intro-sub {
  font-family: var(--font-body);
  font-size: var(--text-md);
  color: var(--fg-2);
  letter-spacing: 0.05em;
  text-align: center;
  animation: slideUp 1.2s 0.8s both;
}
.intro-btn {
  margin-top: var(--sp-4);
  font-family: var(--font-display);
  font-size: var(--text-base);
  font-weight: 700;
  letter-spacing: 0.2em;
  color: var(--fg);
  background: transparent;
  border: 1px solid var(--border-2);
  padding: 14px 52px;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
  animation: slideUp 1.2s 1.1s both;
  min-height: var(--target-lg);
}
.intro-btn:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.28); }

/* ─────────────────────────────────────────
   LAYOUT
───────────────────────────────────────── */
.layout { display: flex; height: 100vh; }

/* ─────────────────────────────────────────
   SIDEBAR
───────────────────────────────────────── */
.sidebar {
  width: 33.333vw;
  min-width: 220px;
  background: var(--surface);
  display: flex; flex-direction: column;
  overflow: hidden;
  border-right: 1px solid var(--border-2);
  flex-shrink: 0;
}

.category-tabs {
  display: flex; flex-wrap: wrap;
  padding: var(--sp-2) var(--sp-3);
  flex-shrink: 0; gap: 4px;
  border-top: 1px solid var(--border-2);
  border-bottom: 1px solid var(--border-2);
}

.cat-tab {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--fg-2);
  background: transparent;
  border: 1px solid var(--border-2);
  border-radius: 0;
  height: 28px;
  padding: 0 var(--sp-3);
  cursor: pointer; white-space: nowrap;
  transition: background 0.1s, color 0.1s;
  flex-shrink: 0;
}
.cat-tab:hover { background: var(--surface-2); color: var(--fg); }
.cat-tab.active { background: var(--fg); color: #000; border-color: var(--fg); }

.search-bar { padding: var(--sp-2) var(--sp-3); flex-shrink: 0; }
.search-input-wrapper {
  display: flex; align-items: center;
  background: var(--bg);
  padding: 0 var(--sp-2); gap: var(--sp-2);
  border: 1px solid var(--border-2);
  height: 32px;
  border-radius: 0;
}
.search-icon { flex-shrink: 0; width: 14px; height: 14px; opacity: 0.5; color: var(--fg); }
.search-input-wrapper input {
  background: none; border: none; outline: none;
  color: var(--fg);
  font-size: var(--text-xs);
  letter-spacing: 0.08em;
  text-transform: uppercase;
  width: 100%;
}
.search-input-wrapper input::placeholder { color: var(--fg-3); text-transform: uppercase; }

/* Clip preview */
.clip-preview-section { flex-shrink: 0; border-bottom: 1px solid var(--border); }
.clip-preview-container {
  background: var(--bg);
  display: flex; align-items: center; justify-content: center;
  height: 200px; position: relative; cursor: pointer;
  overflow: hidden;
}
.clip-preview-container video {
  width: 100%; height: 100%; display: block;
  object-fit: contain; background: var(--bg);
}
.clip-scrubber { height: 3px; background: var(--surface-2); cursor: pointer; position: relative; }
.clip-scrubber-fill { height: 100%; background: var(--accent); width: 0%; pointer-events: none; transition: width 0.05s linear; }

/* Scrollable: media grid + stamps */
.sidebar-scroll {
  flex: 1; overflow-y: auto; overflow-x: hidden;
  display: flex; flex-direction: column; min-height: 0;
}
.sidebar-scroll::-webkit-scrollbar { width: 3px; }
.sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
.sidebar-scroll::-webkit-scrollbar-thumb { background: var(--fg-3); border-radius: 0; }

.media-grid {
  padding: var(--sp-2); display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr)); gap: var(--sp-1); align-content: start;
  flex-shrink: 0;
}
.card {
  background: var(--bg);
  border-radius: 0;
  padding: var(--sp-2); cursor: grab;
  transition: background 0.1s, border-color 0.1s; user-select: none;
  border: 1px solid var(--border);
}
.card.hidden { display: none; }
.card:active { cursor: grabbing; }
.card:hover { background: var(--surface-2); border-color: var(--border-2); }
.card.active { background: var(--surface-2); border-color: var(--fg); }
.card.active .card-label { color: var(--fg); }
.card-thumb {
  width: 100%; aspect-ratio: 16/9;
  background: var(--surface-2);
  border-radius: 0;
  object-fit: cover; display: block;
}
.card-label {
  margin-top: var(--sp-1);
  font-size: 9px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--fg-2);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.text-stamps-section {
  padding: var(--sp-3);
  border-top: 1px solid var(--border-2);
  flex-shrink: 0;
}
.section-label {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--fg-2);
  margin-bottom: var(--sp-2);
}
.stamp-select-wrapper {
  position: relative;
  margin-bottom: var(--sp-2);
}
.stamp-select-wrapper .stamp-select {
  margin-bottom: 0;
  padding-right: 28px;
}
.stamp-select-arrow {
  position: absolute; right: 8px; top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: var(--fg-3);
}
.stamp-select {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--border-2);
  border-radius: 0;
  padding: 0 var(--sp-3);
  height: 28px;
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--fg-2);
  cursor: pointer;
  appearance: none; -webkit-appearance: none;
}
.stamp-select:hover { border-color: var(--fg); color: var(--fg); }
.stamp-select:focus { outline: none; border-color: var(--fg); }
.stamp {
  background: var(--bg);
  border: 1px solid var(--border-2);
  border-radius: 0;
  padding: 0 var(--sp-3);
  min-height: 28px;
  display: flex; align-items: center; justify-content: center;
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--fg);
  cursor: grab; user-select: none;
  text-align: center; line-height: 1.3;
  transition: background 0.1s, border-color 0.1s;
  margin-top: var(--sp-2);
}
.stamp:hover { background: var(--surface-2); border-color: var(--fg); }
.stamp:active { cursor: grabbing; }
.custom-stamp-input {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--border-2);
  border-radius: 0;
  padding: 0 var(--sp-3);
  height: 28px;
  font-family: var(--font-body);
  font-size: var(--text-xs);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--fg);
  margin-bottom: 0;
}
.custom-stamp-input:focus { outline: none; border-color: var(--fg); }
.custom-stamp-input::placeholder { color: var(--fg-3); text-transform: uppercase; }

/* ─────────────────────────────────────────
   MAIN AREA
───────────────────────────────────────── */
.main-area {
  flex: 1; background: var(--bg);
  display: flex; flex-direction: column; min-width: 0;
  overflow: hidden;
}

.main-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 var(--sp-4);
  border-bottom: 1px solid var(--border-2);
  flex-shrink: 0;
  height: 40px;
  background: var(--surface);
}
.app-title {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--fg-2);
}
.publish-btn {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: #000;
  background: var(--fg);
  border: 1px solid var(--fg);
  height: 28px;
  padding: 0 var(--sp-4);
  cursor: pointer; border-radius: 0;
  transition: background 0.1s, color 0.1s;
}
.publish-btn:hover { background: var(--accent); border-color: var(--accent); }
.publish-btn:disabled { opacity: 0.3; cursor: default; }

.editor-box {
  flex: 1; margin: 8px; min-height: 0;
  display: flex; flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--border-2);
  border-radius: 0;
  overflow: hidden;
}

/* Preview */
.tl-preview-section {
  flex: 1;
  display: flex; align-items: center; justify-content: center;
  min-height: 0; overflow: hidden; position: relative;
  background: #000;
}
.tl-preview-container {
  position: relative;
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
}
.tl-preview-container video {
  max-width: 100%; max-height: 100%;
  object-fit: contain; background: var(--bg);
  display: block;
}
.preview-placeholder {
  color: var(--fg-3); font-size: var(--text-sm);
  position: absolute; pointer-events: none;
  letter-spacing: 0.04em;
}

/* Text overlay container (covers preview, for draggable positioned text) */
#tl-text-container {
  position: absolute; inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 2;
}
.tl-text-item {
  position: absolute;
  transform: translate(-50%, -50%);
  font-family: var(--font-body);
  font-weight: 700;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-red);
  cursor: move;
  pointer-events: auto;
  user-select: none;
  white-space: nowrap;
  /* Black border via text-shadow — no blur */
  text-shadow:
    -2px -2px 0 #000,  0 -2px 0 #000,  2px -2px 0 #000,
     2px  0   0 #000,  2px  2px 0 #000,  0  2px 0 #000,
    -2px  2px 0 #000, -2px  0   0 #000;
}

.controls {
  display: flex; align-items: center; justify-content: center;
  gap: var(--sp-3);
  padding: var(--sp-2) 0;
  flex-shrink: 0;
  border-top: 1px solid var(--border-2);
  background: var(--surface);
}
.ctrl-btn {
  background: var(--bg);
  border: 1px solid var(--border-2);
  border-radius: 0;
  cursor: pointer;
  width: 36px; height: 36px;
  display: flex; align-items: center; justify-content: center;
  transition: background 0.1s, border-color 0.1s;
  flex-shrink: 0;
}
.ctrl-btn:hover { background: var(--surface-2); border-color: var(--fg); }
.ctrl-btn.play-pause {
  width: 44px; height: 44px;
  background: var(--surface-2);
  border-color: var(--fg);
}
.ctrl-btn.play-pause:hover { background: rgba(59,187,59,0.15); }
.ctrl-btn svg { display: block; pointer-events: none; }

.timeline {
  flex-shrink: 0;
  padding: 0 var(--sp-4) var(--sp-3);
  background: var(--surface);
}
.timeline-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: var(--sp-2) 0 var(--sp-1);
}
.time-counter {
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em;
  color: var(--fg-3);
  text-transform: uppercase;
}
.time-counter .used { color: var(--fg); }

/* Text clip property bar */
#text-props {
  display: flex; align-items: center;
  background: var(--surface-2);
  border: 1px solid var(--border-2);
  border-radius: 4px;
  padding: 0 var(--sp-3);
  height: var(--target-sm);
  margin-bottom: var(--sp-2);
  gap: var(--sp-3);
}
#text-props.hidden { display: none; }
.text-props-label {
  font-family: var(--font-display);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-red);
  flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.text-props-size {
  display: flex; align-items: center; gap: var(--sp-2); flex-shrink: 0;
}
.size-label {
  font-size: var(--text-xs);
  color: var(--fg-3);
  letter-spacing: 0.04em;
}
.size-val {
  font-size: var(--text-sm);
  font-weight: 700;
  color: var(--fg-2);
  min-width: 36px;
  text-align: center;
}
.size-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-2);
  font-family: var(--font-body);
  font-size: var(--text-md);
  font-weight: 700;
  width: var(--target-sm); height: var(--target-sm);
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; border-radius: 3px;
  transition: border-color 0.15s, color 0.15s;
  flex-shrink: 0;
}
.size-btn:hover { border-color: var(--border-2); color: var(--fg); }

.ruler {
  height: 24px;
  background: var(--ruler-bg);
  cursor: pointer; overflow: hidden;
  border-radius: 0;
  margin-left: 52px;
  border-bottom: 1px solid var(--border);
}
.ruler canvas { display: block; width: 100%; height: 100%; }

.timeline-body { position: relative; }
.tracks-container { position: relative; }

.track {
  height: var(--track-h);
  background: var(--track-bg);
  border-top: 1px solid var(--border);
  position: relative;
}
.track:last-child { border-bottom: 1px solid var(--border); }
.track.drag-over { background: #061806; }

/* Track type visual differentiation */
.track.track-text  { background: #02070a; }
.track.track-video { background: var(--track-bg); }
.track.track-audio { background: #080902; }

.track-label {
  position: absolute; left: 0; top: 0; bottom: 0;
  width: 52px; z-index: 2;
  font-size: 8px;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--fg-2);
  padding: 0 var(--sp-2);
  user-select: none;
  pointer-events: none;
  text-align: right;
  white-space: nowrap;
  display: flex; align-items: center; justify-content: flex-end;
  background: inherit;
  border-right: 1px solid var(--border-2);
}
.track.track-text  .track-label { color: #ff5555; }
.track.track-audio .track-label { color: var(--fg-2); opacity: 0.65; }

/* Track clip area — starts at label boundary, aligns with ruler */
.track-clips {
  position: absolute; left: 52px; right: 0; top: 0; bottom: 0;
  overflow: hidden;
}

/* Track remove button */
.track-remove {
  position: absolute;
  right: var(--sp-2); top: 50%; transform: translateY(-50%);
  width: var(--target-sm); height: var(--target-sm);
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--fg-3);
  font-size: var(--text-lg);
  cursor: pointer;
  display: none; /* flex when shown */
  align-items: center; justify-content: center;
  z-index: 5; line-height: 1;
  transition: color 0.15s, border-color 0.15s;
}
.track-remove:hover { color: var(--fg-2); border-color: var(--border-2); }

.clip {
  position: absolute;
  top: var(--clip-top); height: var(--clip-h);
  border-radius: 0;
  display: flex; flex-direction: column;
  align-items: flex-start; justify-content: center;
  padding: 0 var(--sp-2);
  font-size: var(--text-2xs);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(59,187,59,0.8);
  cursor: grab; user-select: none;
  overflow: hidden; white-space: nowrap;
  min-width: 14px;
  border: 1px solid rgba(59,187,59,0.3);
}
.clip:active { cursor: grabbing; }
.clip.selected { outline: 1px solid var(--fg); outline-offset: -1px; border-color: var(--fg); }

.clip.clip-text {
  background: rgba(255,51,51,0.06) !important;
  border: 1px solid rgba(255,51,51,0.35);
  color: #ff5555;
  font-family: var(--font-display);
  font-weight: 400;
  font-size: 9px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  align-items: center; justify-content: center;
}
.clip.clip-text.selected {
  outline: 1px solid rgba(255,85,85,0.8);
  background: rgba(255,51,51,0.12) !important;
}
.clip.clip-audio-track {
  background: rgba(59,187,59,0.04) !important;
  border: 1px dashed rgba(59,187,59,0.25);
  color: rgba(59,187,59,0.5);
}


.text-size-ctrl {
  position: absolute; z-index: 20;
  display: flex; align-items: center; gap: var(--sp-2);
  background: rgba(0,0,0,0.9);
  border: 1px solid var(--border-2);
  border-radius: 0;
  padding: 4px 10px;
  pointer-events: auto;
  font-family: var(--font-body);
  font-size: var(--text-xs);
  letter-spacing: 0.06em;
  color: var(--fg);
  transform: translate(-50%, 0);
  white-space: nowrap;
}
.text-size-ctrl.hidden { display: none; }
.text-size-ctrl button {
  background: none; border: none;
  color: var(--fg-2); cursor: pointer;
  font-size: 16px; font-weight: 400;
  font-family: var(--font-body);
  padding: 0 2px; line-height: 1;
}
.text-size-ctrl button:hover { color: var(--accent); }
.text-size-ctrl .tsc-val {
  min-width: 32px; text-align: center; color: var(--fg);
}

.clip-handle {
  position: absolute; top: 0;
  width: 6px; height: 100%;
  cursor: ew-resize; z-index: 2;
}
.clip-handle.left  { left: 0; }
.clip-handle.right { right: 0; }
.clip-handle:hover, .clip-handle.dragging { background: rgba(59,187,59,0.2); }

.clip-label {
  pointer-events: none; overflow: hidden;
  text-overflow: ellipsis; width: 100%; line-height: 1;
}

.playhead {
  position: absolute; top: 0; left: 0;
  width: 1px; height: 100%;
  background: var(--accent);
  pointer-events: none; z-index: 10;
  box-shadow: 0 0 4px rgba(85,255,85,0.5);
}

/* Clip category sub-label */
.clip-cat {
  font-size: 7px;
  letter-spacing: 0.06em;
  color: rgba(59,187,59,0.35);
  text-transform: uppercase;
  line-height: 1;
  pointer-events: none;
  overflow: hidden; text-overflow: ellipsis; width: 100%;
}

/* Export progress overlay */
#publish-overlay {
  display: none; position: fixed; inset: 0;
  background: rgba(0,0,0,0.92); z-index: 9998;
  align-items: center; justify-content: center;
}
#publish-overlay.active { display: flex; }
#export-progress-card {
  background: var(--surface);
  border: 1px solid var(--border-2);
  border-radius: 0;
  padding: 32px 40px;
  display: flex; flex-direction: column;
  align-items: center; gap: 16px;
  min-width: 320px;
}
.exp-label {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 400;
  letter-spacing: 0.1em; text-transform: uppercase;
  color: var(--fg);
}
.exp-bar-bg {
  width: 100%; height: 2px;
  background: var(--surface-2); overflow: hidden;
}
.exp-bar-fill {
  height: 100%; width: 0%;
  background: var(--fg);
  transition: width 0.15s linear;
}
.exp-time {
  font-size: var(--text-xs);
  color: var(--fg-3);
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

/* Drag ghosts */
.drag-ghost {
  position: fixed; pointer-events: none; z-index: 1000;
  opacity: 0.9; padding: var(--sp-1) var(--sp-2);
  background: var(--surface-2); border: 1px solid var(--fg);
  border-radius: 0;
  font-size: var(--text-2xs);
  letter-spacing: 0.08em; color: var(--fg);
  text-transform: uppercase;
}
.stamp-ghost {
  position: fixed; pointer-events: none; z-index: 1000;
  opacity: 0.9; padding: var(--sp-1) var(--sp-3);
  background: rgba(255,51,51,0.08); border: 1px solid rgba(255,51,51,0.5);
  border-radius: 0;
  font-family: var(--font-display);
  font-size: 9px; font-weight: 400;
  text-transform: uppercase; letter-spacing: 0.1em;
  color: #ff5555;
}

/* Scrollbar */
.sidebar-scroll::-webkit-scrollbar { width: 3px; }
.sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
.sidebar-scroll::-webkit-scrollbar-thumb { background: var(--fg-3); border-radius: 0; }
</style>
</head>
<body>

<!-- ── INTRO ── -->
<div id="intro-overlay">
  <h1 class="intro-heading">The truth is<br>out there</h1>
  <p class="intro-sub">You have 60 seconds. Construct your theory.</p>
  <button class="intro-btn" id="intro-begin">Begin</button>
</div>

<!-- ── EXPORT PROGRESS ── -->
<div id="publish-overlay">
  <div id="export-progress-card">
    <div class="exp-label">Rendering your theory…</div>
    <div class="exp-bar-bg">
      <div class="exp-bar-fill" id="exp-bar-fill"></div>
    </div>
    <div class="exp-time" id="exp-time">0 / 0s</div>
    <button id="publish-close" style="background:transparent;border:1px solid var(--border-2);color:var(--fg-3);font-family:var(--font-body);font-size:var(--text-xs);letter-spacing:0.08em;text-transform:uppercase;padding:6px 14px;border-radius:0;cursor:pointer;margin-top:4px;">Cancel</button>
  </div>
</div>

<div class="layout">
  <!-- ── SIDEBAR ── -->
  <div class="sidebar">
    <div class="search-bar">
      <div class="search-input-wrapper">
        <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <input type="text" placeholder="Search media" id="search-input">
      </div>
    </div>

    <div class="clip-preview-section">
      <div class="clip-preview-container" id="clip-preview-container">
        <video id="clip-player" style="display:none;"></video>
      </div>
      <div class="clip-scrubber" id="clip-scrubber">
        <div class="clip-scrubber-fill" id="clip-scrubber-fill"></div>
      </div>
    </div>

    <div class="sidebar-scroll">
      <div class="section-label" style="padding: var(--sp-2) var(--sp-3) 0; flex-shrink:0;">&gt; Video Clips</div>
      <div class="category-tabs">
        <button class="cat-tab active" data-cat="ALL">All</button>
        <button class="cat-tab" data-cat="AUTHORITY">Authority</button>
        <button class="cat-tab" data-cat="EVIDENCE">Evidence</button>
        <button class="cat-tab" data-cat="SECRET">The Secret</button>
        <button class="cat-tab" data-cat="ORDINARY">Ordinary</button>
        <button class="cat-tab" data-cat="REACTION">Reaction</button>
      </div>
      <div class="media-grid" id="media-grid"></div>
      <div class="text-stamps-section">
        <div class="section-label">&gt; Text Stamps</div>
        <div class="stamp-select-wrapper">
          <select class="stamp-select" id="stamp-select">
            <option value="COINCIDENCE?">COINCIDENCE?</option>
            <option value="WHAT ARE THEY HIDING?">WHAT ARE THEY HIDING?</option>
            <option value="EXPOSED">EXPOSED</option>
            <option value="FOLLOW THE MONEY">FOLLOW THE MONEY</option>
            <option value="THEY KNEW">THEY KNEW</option>
            <option value="ASK YOURSELF WHY">ASK YOURSELF WHY</option>
            <option value="LOOK CLOSER">LOOK CLOSER</option>
            <option value="WAKE UP">WAKE UP</option>
            <option value="THE TRUTH IS OUT THERE!">THE TRUTH IS OUT THERE!</option>
          </select>
          <svg class="stamp-select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
        </div>
        <input type="text" class="custom-stamp-input" id="custom-stamp-input" placeholder="Or type your own text…" autocomplete="off">
        <div class="stamp" id="active-stamp" data-stamp="COINCIDENCE?">COINCIDENCE?</div>
      </div>
    </div>
  </div>

  <!-- ── MAIN ── -->
  <div class="main-area">
    <div class="main-header">
      <div></div>
      <button class="publish-btn" id="publish-btn">&gt; COMPILE THEORY</button>
    </div>

    <div class="editor-box">
    <div class="tl-preview-section" id="tl-preview-section">
      <div class="tl-preview-container" id="tl-preview-container">
        <span class="preview-placeholder" id="tl-placeholder"></span>
        <video id="timeline-player" style="display:none;"></video>
        <div id="tl-text-container">
          <div id="text-size-ctrl" class="text-size-ctrl hidden">
            <button id="tsc-down">−</button>
            <span class="tsc-val" id="tsc-val">48px</span>
            <button id="tsc-up">+</button>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="ctrl-btn" id="btn-back" title="Back 5s">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <polygon points="12,4 3,12 12,20" fill="#3bbb3b"/>
          <polygon points="21,4 12,12 21,20" fill="#3bbb3b"/>
        </svg>
      </button>
      <button class="ctrl-btn play-pause" id="btn-play" title="Play / Pause">
        <svg width="26" height="26" viewBox="0 0 36 36" fill="none" id="play-icon">
          <polygon points="8,4 8,32 30,18" fill="#3bbb3b"/>
        </svg>
      </button>
      <button class="ctrl-btn" id="btn-fwd" title="Forward 5s">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <polygon points="12,4 21,12 12,20" fill="#3bbb3b"/>
          <polygon points="3,4 12,12 3,20" fill="#3bbb3b"/>
        </svg>
      </button>
    </div>

    <div class="timeline">
      <div class="timeline-header">
        <div class="time-counter" id="time-counter"><span class="used">0</span> / 60s</div>
      </div>



      <div class="timeline-body">
        <div class="playhead" id="playhead"></div>
        <div class="ruler" id="ruler"><canvas id="ruler-canvas"></canvas></div>
        <div class="tracks-container" id="tracks-container"></div>
      </div>
    </div>
    </div><!-- /.editor-box -->
  </div>
</div>

<script>
/* ─────────────────────────────────────────
   CONSTANTS
───────────────────────────────────────── */
const MAX_DUR   = 60;
const TEXT_DUR  = 5;
const FONT_DEF  = 48;
const FONT_MIN  = 20;
const FONT_MAX  = 96;
const FONT_STEP = 8;

const CLIP_COLORS = [
  '#0b2e0b','#0d340d','#0a2a0a','#0f350f','#0c2f0c',
  '#0e330e','#0b310b','#0d360d','#0c300c','#0f370f'
];

const EYE_ON  = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>`;
const EYE_OFF = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>`;
let colorIdx = 0;

/* ─────────────────────────────────────────
   REFS
───────────────────────────────────────── */
const clipPlayer      = document.getElementById('clip-player');
const clipScrubber    = document.getElementById('clip-scrubber');
const clipScrubFill   = document.getElementById('clip-scrubber-fill');
const clipPreviewCont = document.getElementById('clip-preview-container');
const tlPlayer        = document.getElementById('timeline-player');
const tlPlaceholder   = document.getElementById('tl-placeholder');
const tlTextCont      = document.getElementById('tl-text-container');
const tlPreviewCont   = document.getElementById('tl-preview-container');
const searchInput     = document.getElementById('search-input');
const mediaGrid       = document.getElementById('media-grid');
const btnPlay         = document.getElementById('btn-play');
const playIcon        = document.getElementById('play-icon');
const btnBack         = document.getElementById('btn-back');
const btnFwd          = document.getElementById('btn-fwd');
const ruler           = document.getElementById('ruler');
const rulerCanvas     = document.getElementById('ruler-canvas');
const rCtx            = rulerCanvas.getContext('2d');
const playhead        = document.getElementById('playhead');
const tracksCont      = document.getElementById('tracks-container');
const timeCounter     = document.getElementById('time-counter');


const getTracks = () => document.querySelectorAll('.track');

/* ─────────────────────────────────────────
   STATE
───────────────────────────────────────── */
let trackCount   = 0;
let clips        = [];       // all clips (video + text)
let playing      = false;
let playTime     = 0;
let lastRaf      = 0;
let activeVid    = null;
let pendingSeek  = null;
let tlSrc        = '';
let selIds       = new Set();
let assetMeta    = {};
let activeCat    = 'ALL';

// Live text overlay elements (clipId → DOM el)
const textEls = new Map();
// Audio-only clip players (clipId → HTMLVideoElement)
const audioTracks = new Map();

/* ─────────────────────────────────────────
   UNDO
───────────────────────────────────────── */
const undo$ = [];
const pushUndo = () => { undo$.push(JSON.stringify(clips)); if (undo$.length > 50) undo$.shift(); };
const undo = () => {
  if (!undo$.length) return;
  clips = JSON.parse(undo$.pop());
  selIds.clear(); teardownAudioTracks(); renderClips(); updateCounter(); updateTextProps(); syncPreview();
};

/* ─────────────────────────────────────────
   INTRO
───────────────────────────────────────── */
document.getElementById('intro-begin').addEventListener('click', () => {
  const o = document.getElementById('intro-overlay');
  o.classList.add('dismissing');
  o.addEventListener('animationend', () => o.remove(), { once: true });
});

/* ─────────────────────────────────────────
   CATEGORY TABS
───────────────────────────────────────── */
document.querySelectorAll('.cat-tab').forEach(t => t.addEventListener('click', () => {
  document.querySelectorAll('.cat-tab').forEach(x => x.classList.remove('active'));
  t.classList.add('active'); activeCat = t.dataset.cat; filterGrid();
}));
function filterGrid() {
  const q = searchInput.value.trim().toLowerCase();
  document.querySelectorAll('#media-grid .card').forEach(c => {
    const catOk  = activeCat === 'ALL' || c.dataset.category === activeCat;
    const srchOk = !q || (c.dataset.label||'').toLowerCase().includes(q) || (c.dataset.category||'').toLowerCase().includes(q);
    c.classList.toggle('hidden', !catOk || !srchOk);
  });
}
searchInput.addEventListener('input', filterGrid);
searchInput.addEventListener('keydown', e => e.stopPropagation());

/* ─────────────────────────────────────────
   COUNTER
───────────────────────────────────────── */
function updateCounter() {
  let max = 0;
  clips.forEach(c => { max = Math.max(max, c.start + c.duration); });
  const used = Math.min(Math.round(max), MAX_DUR);
  timeCounter.innerHTML = `<span class="used">${used}</span> / 60s`;
}

/* ─────────────────────────────────────────
   TEXT PROPS BAR
───────────────────────────────────────── */
function updateTextProps() {
  if (selIds.size !== 1) { tscCtrl.classList.add('hidden'); return; }
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') { tscCtrl.classList.add('hidden'); return; }
  if (playTime < clip.start || playTime >= clip.start + clip.duration) { tscCtrl.classList.add('hidden'); return; }
  tscVal.textContent = clip.fontSize + 'px';
  // Position overlay near the text element in preview
  tscCtrl.style.left = (clip.textX ?? 50) + '%';
  tscCtrl.style.top  = 'calc(' + (clip.textY ?? 75) + '% - ' + (clip.fontSize / 2 + 32) + 'px)';
  tscCtrl.classList.remove('hidden');
}
const tscCtrl = document.getElementById('text-size-ctrl');
const tscVal  = document.getElementById('tsc-val');
document.getElementById('tsc-down').addEventListener('click', () => {
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') return;
  clip.fontSize = Math.max(FONT_MIN, clip.fontSize - FONT_STEP);
  tscVal.textContent = clip.fontSize + 'px';
  updateTextOverlays(playTime);
});
document.getElementById('tsc-up').addEventListener('click', () => {
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') return;
  clip.fontSize = Math.min(FONT_MAX, clip.fontSize + FONT_STEP);
  tscVal.textContent = clip.fontSize + 'px';
  updateTextOverlays(playTime);
});

/* ─────────────────────────────────────────
   FIXED 3-TRACK INIT
───────────────────────────────────────── */
const TRACK_DEFS = [
  { idx: 0, type: 'text',  label: 'TEXT'  },
  { idx: 1, type: 'video', label: 'VIDEO' },
  { idx: 2, type: 'audio', label: 'AUDIO' },
];

function initTracks() {
  TRACK_DEFS.forEach(def => {
    const track = document.createElement('div');
    track.className = 'track track-' + def.type;
    track.dataset.track = def.idx;
    const lbl = document.createElement('span');
    lbl.className = 'track-label';
    lbl.textContent = def.label;
    const clipArea = document.createElement('div');
    clipArea.className = 'track-clips';
    clipArea.dataset.trackClips = def.idx;
    track.appendChild(lbl);
    track.appendChild(clipArea);
    tracksCont.appendChild(track);
  });
}
initTracks();

/* ─────────────────────────────────────────
   CLIP PREVIEW (LEFT PANEL)
───────────────────────────────────────── */
clipPreviewCont.addEventListener('mousedown', e => {
  if (!clipPlayer.duration) return; e.preventDefault();
  const sx = e.clientX; let scrub = false;
  const onMove = e2 => {
    if (!scrub && Math.abs(e2.clientX - sx) > 3) { scrub = true; clipPlayer.pause(); }
    if (scrub) {
      const r = clipPreviewCont.getBoundingClientRect();
      const p = Math.max(0, Math.min(1, (e2.clientX - r.left) / r.width));
      clipPlayer.currentTime = p * clipPlayer.duration; clipScrubFill.style.width = p*100+'%';
    }
  };
  const onUp = () => {
    document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
    if (!scrub) clipPlayer.paused ? clipPlayer.play() : clipPlayer.pause();
  };
  document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
});

clipScrubber.addEventListener('mousedown', e => {
  const seek = e2 => {
    if (!clipPlayer.duration) return;
    const r = clipScrubber.getBoundingClientRect();
    const p = Math.max(0, Math.min(1, (e2.clientX - r.left) / r.width));
    clipPlayer.currentTime = p * clipPlayer.duration; clipScrubFill.style.width = p*100+'%';
  };
  seek(e);
  const up = () => { document.removeEventListener('mousemove', seek); document.removeEventListener('mouseup', up); };
  document.addEventListener('mousemove', seek); document.addEventListener('mouseup', up);
});

clipPlayer.addEventListener('timeupdate', () => {
  if (clipPlayer.duration) clipScrubFill.style.width = clipPlayer.currentTime/clipPlayer.duration*100+'%';
});
clipPlayer.addEventListener('ended', () => { clipScrubFill.style.width = '100%'; });

/* ─────────────────────────────────────────
   THUMBNAILS
───────────────────────────────────────── */
function generateThumb(card) {
  const v = document.createElement('video');
  v.preload = 'metadata'; v.muted = true; v.src = card.dataset.src;
  v.addEventListener('loadedmetadata', () => { v.currentTime = v.duration*(0.2+Math.random()*0.3); card.dataset.duration = v.duration; });
  v.addEventListener('seeked', () => {
    const c = card.querySelector('.card-thumb');
    c.width = v.videoWidth; c.height = v.videoHeight;
    c.getContext('2d').drawImage(v, 0, 0, c.width, c.height);
    v.src=''; v.load();
  });
}

/* ─────────────────────────────────────────
   CARD SETUP
───────────────────────────────────────── */
function setupCard(card) {
  card.addEventListener('click', () => {
    document.querySelectorAll('#media-grid .card').forEach(c => c.classList.remove('active'));
    card.classList.add('active');
    clipPlayer.style.display = 'block';
    clipPlayer.src = card.dataset.src; clipPlayer.play();
    clipScrubFill.style.width = '0%';
  });
  card.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const sx = e.clientX, sy = e.clientY;
    let drag = false, ghost = null;
    const data = { src: card.dataset.src, label: card.dataset.label, duration: parseFloat(card.dataset.duration)||30, category: card.dataset.category };
    const onMove = e2 => {
      if (!drag && (Math.abs(e2.clientX-sx)>5 || Math.abs(e2.clientY-sy)>5)) {
        drag = true; ghost = mkGhost(data.label, 'drag-ghost'); document.body.appendChild(ghost);
      }
      if (drag && ghost) {
        posGhost(ghost, e2);
        getTracks().forEach(t => t.classList.remove('drag-over'));
        e2.target?.closest?.('.track')?.classList.add('drag-over');
      }
    };
    const onUp = e2 => {
      document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
      ghost?.remove(); getTracks().forEach(t => t.classList.remove('drag-over'));
      if (drag) {
        const clipArea = e2.target?.closest?.('.track-clips');
        if (clipArea) {
          const trackIdx = parseInt(clipArea.dataset.trackClips);
          const r = clipArea.getBoundingClientRect();
          const t = Math.max(0, Math.min((e2.clientX-r.left)/r.width*MAX_DUR, MAX_DUR-0.5));
          if (trackIdx === 0) {
            // Text layer — use the video's title as the stamp text
            addTextClip(0, t, data.label.toUpperCase());
          } else {
            const d = Math.min(data.duration, MAX_DUR-t);
            if (d > 0.5) addVideoClip(trackIdx, t, d, data.src, data.label, data.duration, data.category);
          }
        }
      }
    };
    document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
  });
}

/* ─────────────────────────────────────────
   STAMP DRAG → TEXT LAYER CLIP
───────────────────────────────────────── */
document.getElementById('stamp-select').addEventListener('change', e => {
  const stampEl = document.getElementById('active-stamp');
  stampEl.dataset.stamp = e.target.value;
  stampEl.textContent = e.target.value;
  document.getElementById('custom-stamp-input').value = '';
});
document.getElementById('custom-stamp-input').addEventListener('input', e => {
  const val = e.target.value.trim() || document.getElementById('stamp-select').value;
  const stampEl = document.getElementById('active-stamp');
  stampEl.dataset.stamp = val;
  stampEl.textContent = val || '—';
});
document.getElementById('custom-stamp-input').addEventListener('keydown', e => e.stopPropagation());

document.querySelectorAll('.stamp').forEach(stamp => {
  stamp.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const sx = e.clientX, sy = e.clientY;
    const text = stamp.dataset.stamp;
    let drag = false, ghost = null;
    const onMove = e2 => {
      if (!drag && (Math.abs(e2.clientX-sx)>5 || Math.abs(e2.clientY-sy)>5)) {
        drag = true; ghost = mkGhost(text, 'stamp-ghost'); document.body.appendChild(ghost);
      }
      if (drag && ghost) {
        posGhost(ghost, e2);
        getTracks().forEach(t => t.classList.remove('drag-over'));
        e2.target?.closest?.('.track')?.classList.add('drag-over');
      }
    };
    const onUp = e2 => {
      document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
      ghost?.remove(); getTracks().forEach(t => t.classList.remove('drag-over'));
      if (drag) {
        const clipArea = e2.target?.closest?.('.track-clips');
        if (clipArea) {
          const trackIdx = parseInt(clipArea.dataset.trackClips);
          const r = clipArea.getBoundingClientRect();
          const t = Math.max(0, Math.min((e2.clientX-r.left)/r.width*MAX_DUR, MAX_DUR-TEXT_DUR));
          addTextClip(trackIdx, t, text);
        }
      }
    };
    document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
  });
});

function mkGhost(text, cls) { const d = document.createElement('div'); d.className = cls; d.textContent = text; return d; }
function posGhost(g, e) { g.style.left = e.clientX+12+'px'; g.style.top = e.clientY-16+'px'; }

/* ─────────────────────────────────────────
   MEDIA LIBRARY
───────────────────────────────────────── */
const FALLBACK = [
  '40k end up in morgues.mp4','a_bomb.mp4','come stay in this hotel.mp4',
  'enemy would like.mp4','lesbian implications.mp4','psychiatrists believe.mp4',
  'sign of a poorly-balanced economy.mp4','through the mouth and nose.mp4',
  'traffic signs.mp4','where does pollution come from.mp4'
];
async function loadMeta() { try { const r=await fetch('Assets/metadata.json'); return r.ok?await r.json():{}; } catch { return {}; } }
async function scanAssets() {
  try {
    const r = await fetch('Assets/'); if (!r.ok) return [];
    const doc = new DOMParser().parseFromString(await r.text(),'text/html');
    const files = [];
    doc.querySelectorAll('a').forEach(a => {
      const h = a.getAttribute('href');
      if (h && /\.mp4$/i.test(h)) {
        const raw = h.split('/').pop(), dec = decodeURIComponent(raw);
        files.push({ src:'Assets/'+raw, label: dec.replace(/\.mp4$/i,'').replace(/[_-]/g,' '), filename: dec });
      }
    });
    return files;
  } catch { return []; }
}
function buildList(names) {
  return names.map(f => ({ src:'Assets/'+encodeURIComponent(f), label:f.replace(/\.mp4$/i,'').replace(/[_-]/g,' '), filename:f }));
}
function addCard(f) {
  const card = document.createElement('div');
  card.className='card'; card.dataset.src=f.src;
  card.dataset.label = f.label.toLowerCase();
  card.dataset.category = assetMeta[f.filename]||'ALL';
  const canvas = document.createElement('canvas'); canvas.className='card-thumb'; card.appendChild(canvas);
  const lbl = document.createElement('div'); lbl.className='card-label'; lbl.textContent=f.label; card.appendChild(lbl);
  mediaGrid.appendChild(card); generateThumb(card); setupCard(card);
}
async function loadLibrary() {
  assetMeta = await loadMeta();
  let files = await scanAssets();
  if (!files.length) files = buildList(FALLBACK);
  files.sort((a,b)=>a.label.localeCompare(b.label));
  files.forEach(addCard);
  filterGrid(); // Re-apply active filter after all cards are in the DOM
}

/* ─────────────────────────────────────────
   CLIP CREATION
───────────────────────────────────────── */
function addVideoClip(track, start, dur, src, label, srcDur, category) {
  const s = Math.max(0, start);
  const d = Math.min(dur, MAX_DUR - start);
  if (d <= 0.5) return;
  pushUndo();
  clips.push({
    id: Date.now()+Math.random(), type:'video', track,
    start: s, duration: d,
    src, label, srcDuration:srcDur, srcOffset:0,
    color: CLIP_COLORS[colorIdx++ % CLIP_COLORS.length],
    category: category || 'ALL'
  });
  renderClips(); drawRuler(); syncPreview(); updateCounter();
}
function addTextClip(track, start, text) {
  const clipStart = Math.max(0, start);
  const clipDur   = Math.min(TEXT_DUR, MAX_DUR - start);
  pushUndo();
  clips.push({
    id: Date.now()+Math.random(), type:'text', track,
    start: clipStart, duration: clipDur,
    text, fontSize:FONT_DEF, textX:50, textY:75
  });
  if (playTime < clipStart || playTime >= clipStart + clipDur) {
    playTime = clipStart;
    updatePlayhead();
  }
  renderClips(); drawRuler(); syncPreview(); updateCounter();
}

/* ─────────────────────────────────────────
   OVERLAP HELPERS
───────────────────────────────────────── */
function wouldOverlap(track, start, duration, excludeId = null) {
  return clips.some(c =>
    c.id !== excludeId &&
    c.track === track &&
    start < c.start + c.duration &&
    start + duration > c.start
  );
}

// Snap-to-edge: returns the nearest valid start position for a clip,
// snapping to the adjacent clip's edge rather than freezing in place.
function clampDragStart(clip, desired) {
  const raw = Math.max(0, Math.min(MAX_DUR - clip.duration, desired));
  const peers = clips.filter(c => c.id !== clip.id && c.track === clip.track);
  let result = raw;
  for (const p of peers) {
    if (result < p.start + p.duration && result + clip.duration > p.start) {
      // Snap to whichever edge is closer
      result = desired >= p.start ? p.start + p.duration : p.start - clip.duration;
    }
  }
  return Math.max(0, Math.min(MAX_DUR - clip.duration, result));
}

/* ─────────────────────────────────────────
   RENDER CLIPS
───────────────────────────────────────── */
function renderClips() {
  document.querySelectorAll('.clip').forEach(el => el.remove());
  clips.forEach(clip => {
    const clipArea = document.querySelector(`.track-clips[data-track-clips="${clip.track}"]`);
    if (!clipArea) return;
    const isText = clip.type === 'text';
    const el = document.createElement('div');
    const isAudioTrack = clip.track === 2; // audio track
    el.className = 'clip' + (isText?' clip-text':'') + (selIds.has(clip.id)?' selected':'') + (!isText && isAudioTrack?' clip-audio-track':'');
    el.dataset.clipId = clip.id;
    el.style.left  = (clip.start    / MAX_DUR * 100) + '%';
    el.style.width = (clip.duration / MAX_DUR * 100) + '%';
    if (!isText) el.style.background = clip.color;

    const hL = document.createElement('div'); hL.className='clip-handle left';
    const hR = document.createElement('div'); hR.className='clip-handle right';
    const lbl = document.createElement('span'); lbl.className='clip-label';
    lbl.textContent = isText ? 'TEXT' : '';
    if (isText) { lbl.style.fontFamily='var(--font-display)'; lbl.style.fontSize='8px'; lbl.style.textAlign='center'; lbl.style.width='100%'; }

    el.appendChild(hL); el.appendChild(lbl);
    el.appendChild(hR);
    clipArea.appendChild(el);

    el.addEventListener('click', e => {
      e.stopPropagation();
      if (e.shiftKey||e.metaKey||e.ctrlKey) { selIds.has(clip.id)?selIds.delete(clip.id):selIds.add(clip.id); }
      else { if (selIds.has(clip.id)&&selIds.size===1) selIds.clear(); else { selIds.clear(); selIds.add(clip.id); } }
      renderClips(); updateTextProps();
    });
    setupClipDrag(el, clip, clipArea);
    setupResize(hL, clip, 'left', clipArea);
    setupResize(hR, clip, 'right', clipArea);
  });
}

function setupClipDrag(el, clip, clipArea) {
  el.addEventListener('mousedown', e => {
    if (e.target.classList.contains('clip-handle')) return;
    e.stopPropagation(); e.preventDefault();
    const sx = e.clientX, os = clip.start; let pushed = false;
    const onMove = e2 => {
      if (!pushed) { pushUndo(); pushed=true; }
      const rRect = ruler.getBoundingClientRect();
      const desired = os + ((e2.clientX - sx) / rRect.width) * MAX_DUR;
      const newArea = e2.target?.closest?.('.track-clips');
      if (newArea) {
        const newTrack = parseInt(newArea.dataset.trackClips);
        if (!(clip.type === 'video' && newTrack === 0)) clip.track = newTrack;
      }
      clip.start = Math.max(0, Math.min(MAX_DUR - clip.duration, desired));
      renderClips(); updateCounter();
    };
    const onUp = () => { document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

function setupResize(handle, clip, side, clipArea) {
  handle.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault(); pushUndo();
    const sx=e.clientX, os=clip.start, od=clip.duration, oo=clip.srcOffset||0;
    handle.classList.add('dragging');
    const onMove = e2 => {
      const dt = ((e2.clientX-sx)/ruler.getBoundingClientRect().width)*MAX_DUR;
      if (side==='left') {
        const ns = Math.max(0, os+dt);
        const d  = ns - os;
        const nd = od - d;
        const newOffset = oo + d;
        if (nd > 0.5 && (clip.type==='text' || newOffset >= 0)) {
          clip.start = ns; clip.duration = nd;
          if (clip.type !== 'text') clip.srcOffset = newOffset;
        }
      } else {
        const maxD = clip.type==='text' ? MAX_DUR-clip.start : Math.min(clip.srcDuration-oo, MAX_DUR-clip.start);
        clip.duration = Math.max(0.5, Math.min(od+dt, maxD));
      }
      renderClips(); updateCounter();
    };
    const onUp = () => { handle.classList.remove('dragging'); document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

/* ─────────────────────────────────────────
   TEXT OVERLAY (PREVIEW) — DRAGGABLE
───────────────────────────────────────── */
function getActiveTextClips(t) {
  return clips
    .filter(c => c.type==='text' && t>=c.start && t<c.start+c.duration)
    .sort((a,b) => b.track - a.track); // highest track idx = lowest layer (bottom render)
}

function updateTextOverlays(t) {
  const active = getActiveTextClips(t);
  const activeIds = new Set(active.map(c=>c.id));

  // Remove stale
  for (const [id, el] of textEls) {
    if (!activeIds.has(id)) { el.remove(); textEls.delete(id); }
  }
  // Add / update
  active.forEach(clip => {
    let el = textEls.get(clip.id);
    if (!el) {
      el = document.createElement('div');
      el.className = 'tl-text-item';
      tlTextCont.appendChild(el);
      textEls.set(clip.id, el);
      setupTextDrag(el, clip);
    }
    el.textContent = clip.text;
    el.style.fontSize = clip.fontSize + 'px';
    el.style.left = (clip.textX ?? 50) + '%';
    el.style.top  = (clip.textY ?? 75) + '%';
  });
}

function setupTextDrag(el, clip) {
  el.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault();
    const rect = tlPreviewCont.getBoundingClientRect();
    const sx = e.clientX, sy = e.clientY;
    const ox = clip.textX ?? 50, oy = clip.textY ?? 75;
    const onMove = e2 => {
      clip.textX = Math.max(0, Math.min(100, ox + ((e2.clientX-sx)/rect.width)*100));
      clip.textY = Math.max(0, Math.min(100, oy + ((e2.clientY-sy)/rect.height)*100));
      el.style.left = clip.textX + '%';
      el.style.top  = clip.textY + '%';
    };
    const onUp = () => { document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

/* ─────────────────────────────────────────
   AUDIO TRACK POOL (audio-only clips)
───────────────────────────────────────── */
function syncAudioTracks() {
  const t = playTime;
  const audioClips = clips.filter(c =>
    c.type === 'video' && c.track === 2 && t >= c.start && t < c.start + c.duration
  );
  const activeIds = new Set(audioClips.map(c => c.id));

  // Remove stale players
  for (const [id, el] of audioTracks) {
    if (!activeIds.has(id)) {
      el.pause(); el.src = ''; el.remove();
      audioTracks.delete(id);
    }
  }

  // Add / update players
  for (const clip of audioClips) {
    let el = audioTracks.get(clip.id);
    if (!el) {
      el = document.createElement('video');
      el.style.display = 'none';
      el.preload = 'auto';
      el.src = clip.src;
      document.body.appendChild(el);
      audioTracks.set(clip.id, el);
    }
    const target = clip.srcOffset + (t - clip.start);
    if (Math.abs(el.currentTime - target) > 0.4) el.currentTime = target;
    if (playing && el.paused && !el.ended) el.play().catch(()=>{});
    else if (!playing && !el.paused) el.pause();
  }
}

function teardownAudioTracks() {
  for (const [, el] of audioTracks) { el.pause(); el.src = ''; el.remove(); }
  audioTracks.clear();
}

/* ─────────────────────────────────────────
   PREVIEW SYNC
───────────────────────────────────────── */
function getVideoAt(t) {
  // The clip rendered on top (highest index in clips array = most recently placed)
  // takes priority when clips overlap. Audio track clips contribute sound only.
  let best = null;
  let bestIdx = -1;
  clips.forEach((c, i) => {
    if (c.type !== 'video') return;
    if (c.track === 2) return; // audio track
    if (t >= c.start && t < c.start + c.duration) {
      if (i > bestIdx) { best = c; bestIdx = i; }
    }
  });
  return best;
}

function syncPreview() {
  const vClip = getVideoAt(playTime);
  if (vClip) {
    tlPlaceholder.style.display = 'none'; tlPlayer.style.display = 'block';
    const tgt = Math.max(0, vClip.srcOffset + (playTime - vClip.start));
    if (tlSrc !== vClip.src) {
      // New source — load and queue seek
      tlPlayer.pause(); pendingSeek = vClip; tlSrc = vClip.src;
      tlPlayer.src = vClip.src; tlPlayer.load();
    } else {
      // Same source — only seek if time is significantly off (avoids seek-spam during play)
      const drift = Math.abs(tlPlayer.currentTime - tgt);
      if (!playing || drift > 0.3) tlPlayer.currentTime = tgt;
      if (playing && tlPlayer.paused && !tlPlayer.seeking && !pendingSeek) {
        tlPlayer.play().catch(() => {});
      }
    }
    activeVid = vClip;
  } else {
    tlPlayer.pause(); activeVid = null;
    if (!getActiveTextClips(playTime).length) {
      tlPlaceholder.style.display = ''; tlPlayer.style.display = 'none';
    } else {
      tlPlaceholder.style.display = 'none';
    }
  }
  updateTextOverlays(playTime);
  syncAudioTracks();
}

tlPlayer.addEventListener('loadeddata', () => {
  if (pendingSeek) {
    const c = pendingSeek; pendingSeek = null;
    tlPlayer.currentTime = Math.max(0, c.srcOffset+(playTime-c.start));
    if (playing) tlPlayer.play();
  }
});

tlPlayer.addEventListener('seeked', () => {
  if (playing && tlPlayer.paused && !pendingSeek) {
    tlPlayer.play().catch(() => {});
  }
});

tlPlayer.addEventListener('ended', () => {
  // Video finished — advance playTime past the clip so tick picks up the next one
  if (playing && activeVid) {
    playTime = activeVid.start + activeVid.duration;
    activeVid = null;
    syncPreview();
  }
});

/* ─────────────────────────────────────────
   PLAYBACK
───────────────────────────────────────── */
function setPlayIcon(showPlay) {
  playIcon.innerHTML = showPlay
    ? '<polygon points="8,4 8,32 30,18" fill="#3bbb3b"/>'
    : '<rect x="7" y="5" width="7" height="26" rx="1" fill="#3bbb3b"/><rect x="22" y="5" width="7" height="26" rx="1" fill="#3bbb3b"/>';
}
btnPlay.addEventListener('click', () => playing ? stop() : start());

function getNextClipTime(t) {
  const starts = [...new Set(clips.map(c => c.start))].filter(s => s > t + 0.05).sort((a,b)=>a-b);
  return starts.length ? starts[0] : null;
}
function getPrevClipTime(t) {
  const starts = [...new Set(clips.map(c => c.start))].filter(s => s < t - 0.05).sort((a,b)=>b-a);
  return starts.length ? starts[0] : 0;
}

btnBack.addEventListener('click', () => {
  const prev = getPrevClipTime(playTime);
  playTime = prev !== null ? prev : 0;
  updatePlayhead(); syncPreview();
});
btnFwd.addEventListener('click', () => {
  const next = getNextClipTime(playTime);
  if (next !== null) { playTime = next; updatePlayhead(); syncPreview(); }
});

function start() {
  if (!clips.length) return;
  playing=true; setPlayIcon(false); lastRaf=performance.now(); syncPreview(); requestAnimationFrame(tick);
}
function stop() { playing=false; setPlayIcon(true); tlPlayer.pause(); activeVid=null; teardownAudioTracks(); }

function tick(now) {
  if (!playing) return;
  const dt = (now - lastRaf) / 1000;
  lastRaf = now;

  // Derive playTime from video when playing — prevents wall-clock drift
  if (activeVid && !tlPlayer.paused && !tlPlayer.seeking && !tlPlayer.ended) {
    playTime = activeVid.start + (tlPlayer.currentTime - activeVid.srcOffset);
  } else {
    playTime += dt;
  }

  if (playTime >= MAX_DUR) { playTime=0; stop(); updatePlayhead(); return; }
  updatePlayhead();
  const nowVid = getVideoAt(playTime);
  if (nowVid !== activeVid) {
    syncPreview();
  } else {
    updateTextOverlays(playTime);
    syncAudioTracks();
    updateTextProps();
  }
  requestAnimationFrame(tick);
}

/* ─────────────────────────────────────────
   RULER
───────────────────────────────────────── */
function drawRuler() {
  const dpr = window.devicePixelRatio||1;
  const r   = rulerCanvas.getBoundingClientRect();
  rulerCanvas.width=r.width*dpr; rulerCanvas.height=r.height*dpr;
  rCtx.scale(dpr,dpr); rCtx.clearRect(0,0,r.width,r.height);

  const step = (() => { const raw=MAX_DUR/(r.width/40); for (const s of[1,2,5,10,15,30,60]) if(s>=raw) return s; return 60; })();
  for (let i=0; i<=Math.floor(MAX_DUR/step); i++) {
    const t=i*step, x=(t/MAX_DUR)*r.width, maj=i%5===0;
    rCtx.beginPath(); rCtx.moveTo(x,maj?4:14); rCtx.lineTo(x,r.height);
    rCtx.strokeStyle=maj?'#1a4d1a':'#0f2a0f'; rCtx.lineWidth=1; rCtx.stroke();
    if (maj) {
      rCtx.fillStyle='#267026'; rCtx.font='8px "IBM Plex Mono",monospace';
      rCtx.textAlign='left'; rCtx.fillText(Math.floor(t/60)+':'+(t%60).toString().padStart(2,'0'), x+3, 11);
    }
  }
  // 60s cap
  rCtx.beginPath(); rCtx.moveTo(r.width-1,0); rCtx.lineTo(r.width-1,r.height);
  rCtx.strokeStyle='rgba(59,187,59,0.5)'; rCtx.lineWidth=2; rCtx.stroke();
  rCtx.fillStyle='rgba(59,187,59,0.6)'; rCtx.font='400 8px "IBM Plex Mono",monospace';
  rCtx.textAlign='right'; rCtx.fillText('60s', r.width-3, 11); rCtx.textAlign='left';
}

function updatePlayhead() {
  const bodyW = playhead.parentElement.offsetWidth;
  const px = 52 + (playTime / MAX_DUR) * (bodyW - 52);
  playhead.style.left = px + 'px';
}

ruler.addEventListener('mousedown', e => {
  const seek = e2 => {
    const rect=ruler.getBoundingClientRect();
    playTime=Math.max(0,Math.min(1,(e2.clientX-rect.left)/rect.width))*MAX_DUR;
    updatePlayhead(); syncPreview();
  };
  seek(e);
  const up=()=>{ document.removeEventListener('mousemove',seek); document.removeEventListener('mouseup',up); };
  document.addEventListener('mousemove',seek); document.addEventListener('mouseup',up);
});

tracksCont.addEventListener('click', () => {
  if (selIds.size) { selIds.clear(); renderClips(); updateTextProps(); }
});

/* ─────────────────────────────────────────
   KEYBOARD
───────────────────────────────────────── */
document.addEventListener('keydown', e => {
  const introEl = document.getElementById('intro-overlay');
  if (introEl && getComputedStyle(introEl).display !== 'none') return;
  if (e.code==='Space') { e.preventDefault(); btnPlay.click(); }
  if ((e.code==='Backspace'||e.code==='Delete') && selIds.size) {
    e.preventDefault(); pushUndo();
    clips = clips.filter(c=>!selIds.has(c.id));
    selIds.clear(); renderClips(); drawRuler(); syncPreview(); updateCounter(); updateTextProps();
  }
  if (e.code==='KeyZ'&&(e.metaKey||e.ctrlKey)&&!e.shiftKey) { e.preventDefault(); undo(); }
  if (e.code==='Escape') { const po=document.getElementById('publish-overlay'); if(po.classList.contains('active')) { expActive=false; po.classList.remove('active'); } }
});

/* ─────────────────────────────────────────
   EXPORT (MediaRecorder → download)
───────────────────────────────────────── */
const pubOverlay = document.getElementById('publish-overlay');
const expBarFill = document.getElementById('exp-bar-fill');
const expTimeEl  = document.getElementById('exp-time');
let expActive = false;

document.getElementById('publish-btn').addEventListener('click', async () => {
  if (!clips.length) return;
  const totalDur = clips.reduce((m, c) => Math.max(m, c.start + c.duration), 0);
  if (totalDur === 0) return;

  pubOverlay.classList.add('active');
  expActive = true;
  expBarFill.style.width = '0%';
  expTimeEl.textContent = `0 / ${Math.ceil(totalDur)}s`;

  const EXP_W = 1280, EXP_H = 720;
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = EXP_W; exportCanvas.height = EXP_H;
  const ctx = exportCanvas.getContext('2d');

  const expPlayer = document.createElement('video');
  expPlayer.crossOrigin = 'anonymous';
  expPlayer.style.display = 'none';
  document.body.appendChild(expPlayer);

  const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')
    ? 'video/mp4;codecs=avc1'
    : MediaRecorder.isTypeSupported('video/mp4')
    ? 'video/mp4'
    : 'video/webm';

  const canvasStream = exportCanvas.captureStream(30);
  const recorder = new MediaRecorder(canvasStream, { mimeType });
  const chunks = [];

  recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  recorder.onstop = () => {
    expPlayer.remove();
    if (!chunks.length) { pubOverlay.classList.remove('active'); return; }
    const blob = new Blob(chunks, { type: mimeType });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url;
    a.download = 'theory.' + (mimeType.includes('mp4') ? 'mp4' : 'webm');
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
    pubOverlay.classList.remove('active');
  };

  let expTime = 0, expLast = performance.now();
  let expVidSrc = '', expVidClip = null;

  recorder.start(100);

  const expTick = now => {
    if (!expActive) { recorder.stop(); return; }
    const dt = (now - expLast) / 1000; expLast = now;
    expTime += dt;

    if (expTime >= totalDur) {
      ctx.clearRect(0, 0, EXP_W, EXP_H);
      expActive = false; recorder.stop(); return;
    }

    expBarFill.style.width = (expTime / totalDur * 100).toFixed(1) + '%';
    expTimeEl.textContent  = `${expTime.toFixed(1)} / ${Math.ceil(totalDur)}s`;

    // Draw video
    const vClip = getVideoAt(expTime);
    if (vClip) {
      const tgt = Math.max(0, vClip.srcOffset + (expTime - vClip.start));
      if (expVidClip !== vClip) {
        expVidClip = vClip;
        if (expVidSrc !== vClip.src) {
          expVidSrc = vClip.src;
          expPlayer.src = vClip.src;
          expPlayer.currentTime = tgt;
          expPlayer.play().catch(()=>{});
        } else if (Math.abs(expPlayer.currentTime - tgt) > 0.5) {
          expPlayer.currentTime = tgt;
        }
      }
      if (expPlayer.readyState >= 2) {
        ctx.drawImage(expPlayer, 0, 0, EXP_W, EXP_H);
      } else {
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, EXP_W, EXP_H);
      }
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, EXP_W, EXP_H);
    }

    // Draw text overlays
    getActiveTextClips(expTime).forEach(clip => {
      const x = EXP_W * (clip.textX ?? 50) / 100;
      const y = EXP_H * (clip.textY ?? 75) / 100;
      ctx.save();
      ctx.font = `700 ${clip.fontSize * 1.5}px "IBM Plex Mono", monospace`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const offsets = [[-2,-2],[0,-2],[2,-2],[2,0],[2,2],[0,2],[-2,2],[-2,0]];
      ctx.fillStyle = '#000';
      offsets.forEach(([dx,dy]) => ctx.fillText(clip.text.toUpperCase(), x+dx*2, y+dy*2));
      ctx.fillStyle = '#f03030';
      ctx.fillText(clip.text.toUpperCase(), x, y);
      ctx.restore();
    });

    requestAnimationFrame(expTick);
  };

  requestAnimationFrame(expTick);
});

document.getElementById('publish-close').addEventListener('click', () => {
  expActive = false;
  pubOverlay.classList.remove('active');
});

/* ─────────────────────────────────────────
   INIT
───────────────────────────────────────── */
updatePlayhead(); updateCounter(); loadLibrary();
document.fonts.ready.then(()=>drawRuler());
window.addEventListener('resize', ()=>{ drawRuler(); renderClips(); });
</script>
</body>
</html>
