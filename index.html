<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Narrative Construction Kit</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
/* ─────────────────────────────────────────
   DESIGN TOKENS
───────────────────────────────────────── */
:root {
  /* Colour */
  --bg:         #0d0e12;
  --surface:    #14161e;
  --surface-2:  #1b1d27;
  --card:       #1e2030;
  --border:     rgba(255,255,255,0.07);
  --border-2:   rgba(255,255,255,0.14);
  --fg:         #d2d5e0;
  --fg-2:       #6a6d7c;
  --fg-3:       #383c4a;
  --accent:     #bec2d4;
  --track-bg:   #12141c;
  --ruler-bg:   #0f1018;
  --text-red:   #f03030;

  /* Typography */
  --font-display: 'Orbitron', monospace;
  --font-body:    'Space Mono', monospace;
  --text-2xs:  10px;
  --text-xs:   11px;
  --text-sm:   12px;
  --text-base: 13px;
  --text-md:   14px;
  --text-lg:   16px;
  --text-xl:   20px;
  --text-2xl:  24px;

  /* Spacing (4px grid) */
  --sp-1: 4px;
  --sp-2: 8px;
  --sp-3: 12px;
  --sp-4: 16px;
  --sp-5: 20px;
  --sp-6: 24px;

  /* Touch targets */
  --target-sm:  32px;
  --target-md:  40px;
  --target-lg:  44px;
  --target-xl:  52px;

  /* Track */
  --track-h:    48px;
  --clip-top:   5px;
  --clip-h:     38px;
}

/* ─────────────────────────────────────────
   RESET + BASE
───────────────────────────────────────── */
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; overflow: hidden; background: var(--bg); font-family: var(--font-body); color: var(--fg); font-size: var(--text-base); }

button { font-family: inherit; }
input  { font-family: inherit; }

/* ─────────────────────────────────────────
   INTRO OVERLAY
───────────────────────────────────────── */
#intro-overlay {
  position: fixed; inset: 0;
  background: #080910; z-index: 9999;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: var(--sp-5);
  animation: fadeIn 1.4s ease forwards;
}
@keyframes fadeIn  { from { opacity: 0; } to { opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
@keyframes slideUp { from { opacity: 0; transform: translateY(14px); } to { opacity: 1; transform: translateY(0); } }

#intro-overlay.dismissing { animation: fadeOut 0.5s ease forwards; pointer-events: none; }

.intro-heading {
  font-family: var(--font-display);
  font-size: clamp(32px, 7vw, 84px);
  font-weight: 900;
  letter-spacing: 0.05em;
  color: var(--fg);
  text-align: center; line-height: 1.1;
  animation: slideUp 1.2s 0.5s both;
}
.intro-sub {
  font-family: var(--font-body);
  font-size: var(--text-md);
  color: var(--fg-2);
  letter-spacing: 0.05em;
  text-align: center;
  animation: slideUp 1.2s 0.8s both;
}
.intro-btn {
  margin-top: var(--sp-4);
  font-family: var(--font-display);
  font-size: var(--text-base);
  font-weight: 700;
  letter-spacing: 0.2em;
  color: var(--fg);
  background: transparent;
  border: 1px solid var(--border-2);
  padding: 14px 52px;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
  animation: slideUp 1.2s 1.1s both;
  min-height: var(--target-lg);
}
.intro-btn:hover { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.28); }

/* ─────────────────────────────────────────
   LAYOUT
───────────────────────────────────────── */
.layout { display: flex; height: 100vh; }

/* ─────────────────────────────────────────
   SIDEBAR
───────────────────────────────────────── */
.sidebar {
  width: 480px;
  min-width: 480px;
  background: var(--surface);
  display: flex; flex-direction: column;
  overflow: hidden;
  border-right: 1px solid var(--border);
  flex-shrink: 0;
}

/* Category tabs */
.category-tabs {
  display: flex; overflow-x: auto;
  padding: var(--sp-2) var(--sp-3) 0;
  flex-shrink: 0; scrollbar-width: none; gap: 2px;
  border-bottom: 1px solid var(--border);
}
.category-tabs::-webkit-scrollbar { display: none; }

.cat-tab {
  font-family: var(--font-body);
  font-size: var(--text-sm);
  font-weight: 700;
  letter-spacing: 0.03em;
  color: var(--fg-3);
  background: transparent; border: none;
  border-bottom: 2px solid transparent;
  padding: 0 var(--sp-3);
  min-height: var(--target-md);
  cursor: pointer; white-space: nowrap;
  transition: color 0.15s, border-color 0.15s;
  flex-shrink: 0;
}
.cat-tab:hover { color: var(--fg-2); }
.cat-tab.active { color: var(--fg); border-bottom-color: var(--accent); }

/* Search */
.search-bar { padding: var(--sp-3); flex-shrink: 0; }
.search-input-wrapper {
  display: flex; align-items: center;
  background: var(--bg); border-radius: 4px;
  padding: 0 var(--sp-3); gap: var(--sp-2);
  border: 1px solid var(--border);
  height: var(--target-md);
}
.search-icon { flex-shrink: 0; width: 14px; height: 14px; opacity: 0.3; color: var(--fg); }
.search-input-wrapper input {
  background: none; border: none; outline: none;
  color: var(--fg);
  font-size: var(--text-sm);
  letter-spacing: 0.02em;
  width: 100%;
}
.search-input-wrapper input::placeholder { color: var(--fg-3); }

/* Clip preview */
.clip-preview-section { flex-shrink: 0; border-bottom: 1px solid var(--border); }
.clip-preview-container {
  background: var(--bg);
  display: flex; align-items: center; justify-content: center;
  height: 140px; position: relative; cursor: pointer;
  overflow: hidden;
}
.clip-preview-container video {
  width: 100%; height: 100%; display: block;
  object-fit: contain; background: var(--bg);
}
.clip-scrubber { height: 3px; background: var(--surface-2); cursor: pointer; position: relative; }
.clip-scrubber-fill { height: 100%; background: var(--accent); width: 0%; pointer-events: none; transition: width 0.05s linear; }

/* Scrollable: media grid + stamps */
.sidebar-scroll {
  flex: 1; overflow-y: auto; overflow-x: hidden;
  display: flex; flex-direction: column; min-height: 0;
}
.sidebar-scroll::-webkit-scrollbar { width: 4px; }
.sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
.sidebar-scroll::-webkit-scrollbar-thumb { background: var(--fg-3); border-radius: 2px; }

.media-grid {
  padding: var(--sp-3); display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr)); gap: var(--sp-2); align-content: start;
}
.card {
  background: var(--card); border-radius: 4px;
  padding: var(--sp-2); cursor: grab;
  transition: background 0.15s; user-select: none;
  border: 1px solid var(--border);
}
.card.hidden { display: none; }
.card:active { cursor: grabbing; }
.card:hover { background: #252838; }
.card.active { background: var(--accent); border-color: var(--accent); }
.card.active .card-label { color: var(--bg); }
.card-thumb {
  width: 100%; aspect-ratio: 16/9;
  background: var(--surface-2); border-radius: 3px;
  object-fit: cover; display: block;
}
.card-label {
  margin-top: var(--sp-1);
  font-size: var(--text-xs);
  letter-spacing: 0.02em;
  color: var(--fg-2);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* Text stamps */
.text-stamps-section {
  padding: var(--sp-3);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
}
.section-label {
  font-family: var(--font-body);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.05em;
  color: var(--fg-3);
  margin-bottom: var(--sp-2);
}
.stamp-select {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 var(--sp-2);
  height: var(--target-sm);
  font-family: var(--font-display);
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--fg-2);
  cursor: pointer;
  margin-bottom: var(--sp-2);
  appearance: none; -webkit-appearance: none;
}
.stamp-select:hover { border-color: var(--border-2); color: var(--fg); }
.stamp-select:focus { outline: none; border-color: var(--border-2); }
.stamp {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0 var(--sp-2);
  min-height: var(--target-sm);
  display: flex; align-items: center; justify-content: center;
  font-family: var(--font-display);
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--fg-2);
  cursor: grab; user-select: none;
  text-align: center; line-height: 1.3;
  transition: background 0.15s, border-color 0.15s, color 0.15s;
}
.stamp:hover { background: var(--surface-2); border-color: var(--border-2); color: var(--fg); }
.stamp:active { cursor: grabbing; }

/* ─────────────────────────────────────────
   MAIN AREA
───────────────────────────────────────── */
.main-area {
  flex: 1; background: var(--bg);
  display: flex; flex-direction: column; min-width: 0;
  overflow: hidden;
}

/* Header */
.main-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 var(--sp-6);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  height: var(--target-lg);
}
.app-title {
  font-family: var(--font-display);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.18em;
  color: var(--fg-3);
}
.publish-btn {
  font-family: var(--font-body);
  font-size: var(--text-sm);
  font-weight: 700;
  letter-spacing: 0.04em;
  color: var(--bg);
  background: var(--accent);
  border: none;
  height: var(--target-sm);
  padding: 0 var(--sp-4);
  cursor: pointer; border-radius: 3px;
  transition: opacity 0.15s;
}
.publish-btn:hover { opacity: 0.82; }
.publish-btn:disabled { opacity: 0.22; cursor: default; }

/* Preview */
.tl-preview-section {
  flex: 1;
  display: flex; align-items: center; justify-content: center;
  min-height: 0; overflow: hidden; position: relative;
  background: var(--bg);
}
.tl-preview-container {
  position: relative;
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
}
.tl-preview-container video {
  max-width: 100%; max-height: 100%;
  object-fit: contain; background: var(--bg);
  display: block;
}
.preview-placeholder {
  color: var(--fg-3); font-size: var(--text-sm);
  position: absolute; pointer-events: none;
  letter-spacing: 0.04em;
}

/* Text overlay container (covers preview, for draggable positioned text) */
#tl-text-container {
  position: absolute; inset: 0;
  pointer-events: none;
  overflow: hidden;
}
.tl-text-item {
  position: absolute;
  transform: translate(-50%, -50%);
  font-family: var(--font-display);
  font-weight: 900;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-red);
  cursor: move;
  pointer-events: auto;
  user-select: none;
  white-space: nowrap;
  /* Black border via text-shadow — no blur */
  text-shadow:
    -2px -2px 0 #000,  0 -2px 0 #000,  2px -2px 0 #000,
     2px  0   0 #000,  2px  2px 0 #000,  0  2px 0 #000,
    -2px  2px 0 #000, -2px  0   0 #000;
}

/* ─────────────────────────────────────────
   TRANSPORT CONTROLS
───────────────────────────────────────── */
.controls {
  display: flex; align-items: center; justify-content: center;
  gap: var(--sp-4);
  padding: var(--sp-3) 0;
  flex-shrink: 0;
  border-top: 1px solid var(--border);
}
.ctrl-btn {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  width: var(--target-lg); height: var(--target-lg);
  display: flex; align-items: center; justify-content: center;
  transition: background 0.15s, border-color 0.15s;
  flex-shrink: 0;
}
.ctrl-btn:hover { background: var(--surface-2); border-color: var(--border-2); }
.ctrl-btn.play-pause {
  width: var(--target-xl); height: var(--target-xl);
  background: var(--surface-2);
}
.ctrl-btn.play-pause:hover { background: #272a38; }
.ctrl-btn svg { display: block; pointer-events: none; }

/* ─────────────────────────────────────────
   TIMELINE
───────────────────────────────────────── */
.timeline {
  flex-shrink: 0;
  padding: 0 var(--sp-5) var(--sp-3);
}
.timeline-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: var(--sp-2) 0 var(--sp-1);
}
.time-counter {
  font-size: var(--text-sm);
  font-weight: 700;
  letter-spacing: 0.04em;
  color: var(--fg-3);
}
.time-counter .used { color: var(--fg-2); }

/* Text clip property bar */
#text-props {
  display: flex; align-items: center;
  background: var(--surface-2);
  border: 1px solid var(--border-2);
  border-radius: 4px;
  padding: 0 var(--sp-3);
  height: var(--target-sm);
  margin-bottom: var(--sp-2);
  gap: var(--sp-3);
}
#text-props.hidden { display: none; }
.text-props-label {
  font-family: var(--font-display);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-red);
  flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.text-props-size {
  display: flex; align-items: center; gap: var(--sp-2); flex-shrink: 0;
}
.size-label {
  font-size: var(--text-xs);
  color: var(--fg-3);
  letter-spacing: 0.04em;
}
.size-val {
  font-size: var(--text-sm);
  font-weight: 700;
  color: var(--fg-2);
  min-width: 36px;
  text-align: center;
}
.size-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--fg-2);
  font-family: var(--font-body);
  font-size: var(--text-md);
  font-weight: 700;
  width: var(--target-sm); height: var(--target-sm);
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; border-radius: 3px;
  transition: border-color 0.15s, color 0.15s;
  flex-shrink: 0;
}
.size-btn:hover { border-color: var(--border-2); color: var(--fg); }

/* Ruler — indented to match track-clips origin */
.ruler {
  height: 28px;
  background: var(--ruler-bg);
  cursor: pointer; overflow: hidden;
  border-radius: 2px 2px 0 0;
  margin-left: 52px; /* aligns with .track-clips, matching .track-label width */
}
.ruler canvas { display: block; width: 100%; height: 100%; }

/* Tracks */
.timeline-body { position: relative; }
.tracks-container { position: relative; }

.track {
  height: var(--track-h);
  background: var(--track-bg);
  border-top: 1px solid var(--border);
  position: relative;
}
.track:last-child { border-bottom: 1px solid var(--border); }
.track.drag-over { background: #181b26; }

/* Track layer label — absolute overlay so track-clips spans full width */
.track-label {
  position: absolute; left: 0; top: 0; bottom: 0;
  width: 52px; z-index: 2;
  font-size: var(--text-2xs);
  letter-spacing: 0.04em;
  color: var(--fg-3);
  padding: 0 var(--sp-2);
  user-select: none;
  pointer-events: none;
  text-align: right;
  white-space: nowrap;
  display: flex; align-items: center; justify-content: flex-end;
  background: linear-gradient(to right, var(--track-bg) 60%, transparent);
}

/* Track clip area — full track width, same coordinate space as ruler */
.track-clips {
  position: absolute; inset: 0;
}

/* Track remove button */
.track-remove {
  position: absolute;
  right: var(--sp-2); top: 50%; transform: translateY(-50%);
  width: var(--target-sm); height: var(--target-sm);
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--fg-3);
  font-size: var(--text-lg);
  cursor: pointer;
  display: none; /* flex when shown */
  align-items: center; justify-content: center;
  z-index: 5; line-height: 1;
  transition: color 0.15s, border-color 0.15s;
}
.track-remove:hover { color: var(--fg-2); border-color: var(--border-2); }

/* Clips */
.clip {
  position: absolute;
  top: var(--clip-top); height: var(--clip-h);
  border-radius: 3px;
  display: flex; flex-direction: column;
  align-items: flex-start; justify-content: center;
  padding: 0 var(--sp-2);
  font-size: var(--text-2xs);
  letter-spacing: 0.03em;
  color: rgba(255,255,255,0.7);
  cursor: grab; user-select: none;
  overflow: hidden; white-space: nowrap;
  min-width: 14px;
}
.clip:active { cursor: grabbing; }
.clip.selected { outline: 1px solid rgba(255,255,255,0.45); outline-offset: -1px; }

/* Text clips */
.clip.clip-text {
  background: rgba(255,255,255,0.06) !important;
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--text-red);
  font-family: var(--font-display);
  font-weight: 700;
  font-size: 9px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  align-items: center; justify-content: center;
}
.clip.clip-text.selected {
  outline: 1px solid rgba(255,255,255,0.5);
  background: rgba(255,255,255,0.10) !important;
}

.clip-handle {
  position: absolute; top: 0;
  width: 6px; height: 100%;
  cursor: ew-resize; z-index: 2;
}
.clip-handle.left  { left: 0;  border-radius: 3px 0 0 3px; }
.clip-handle.right { right: 0; border-radius: 0 3px 3px 0; }
.clip-handle:hover, .clip-handle.dragging { background: rgba(255,255,255,0.12); }

.clip-label {
  pointer-events: none; overflow: hidden;
  text-overflow: ellipsis; width: 100%; line-height: 1;
}

/* Playhead */
.playhead {
  position: absolute; top: 0; left: 0;
  width: 1px; height: 100%;
  background: var(--fg);
  pointer-events: none; z-index: 10;
  box-shadow: 0 0 3px rgba(210,213,224,0.25);
}

/* Add track */
.add-track-btn {
  height: var(--target-sm); background: transparent;
  border: 1px solid var(--border); width: 100%; margin-top: 2px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; color: var(--fg-3);
  font-size: var(--text-lg);
  border-radius: 3px;
  transition: color 0.15s, border-color 0.15s;
}
.add-track-btn:hover { color: var(--fg-2); border-color: var(--border-2); }

/* Drag ghosts */
.drag-ghost {
  position: fixed; pointer-events: none; z-index: 1000;
  opacity: 0.85; padding: var(--sp-1) var(--sp-2);
  background: var(--surface-2); border: 1px solid var(--border-2);
  border-radius: 3px;
  font-size: var(--text-2xs);
  letter-spacing: 0.03em; color: var(--fg-2);
}
.stamp-ghost {
  position: fixed; pointer-events: none; z-index: 1000;
  opacity: 0.9; padding: var(--sp-1) var(--sp-3);
  background: rgba(240,48,48,0.12); border: 1px solid rgba(240,48,48,0.4);
  border-radius: 3px;
  font-family: var(--font-display);
  font-size: 9px; font-weight: 700;
  text-transform: uppercase; letter-spacing: 0.08em;
  color: var(--text-red);
}

/* ─────────────────────────────────────────
   PUBLISH OVERLAY
───────────────────────────────────────── */
#publish-overlay {
  display: none; position: fixed; inset: 0;
  background: #000; z-index: 9998;
  align-items: center; justify-content: center;
}
#publish-overlay.active { display: flex; }
#publish-video {
  position: absolute; inset: 0;
  width: 100%; height: 100%;
  object-fit: contain; display: none; background: #000;
}
#publish-title-card {
  position: absolute; inset: 0; background: #000;
  display: none; flex-direction: column;
  align-items: center; justify-content: center; gap: var(--sp-4);
  opacity: 0; transition: opacity 0.8s ease;
}
#publish-title-card.visible { opacity: 1; }
.pub-card-title {
  font-family: var(--font-display);
  font-size: clamp(20px, 5vw, 58px);
  font-weight: 900; letter-spacing: 0.08em;
  color: var(--fg);
  text-align: center; line-height: 1.15;
}
.pub-card-sub {
  font-size: var(--text-sm);
  color: var(--fg-2); letter-spacing: 0.1em;
}
#publish-close {
  position: absolute; top: var(--sp-5); right: var(--sp-5); z-index: 10;
  background: transparent; border: 1px solid var(--fg-3);
  color: var(--fg-2);
  font-size: var(--text-sm); letter-spacing: 0.06em;
  height: var(--target-sm); padding: 0 var(--sp-4);
  cursor: pointer; border-radius: 3px;
  transition: color 0.15s, border-color 0.15s;
}
#publish-close:hover { color: var(--fg); border-color: var(--fg-2); }

/* Publish text overlays */
#publish-text-container {
  position: absolute; inset: 0;
  pointer-events: none; z-index: 5;
  overflow: hidden;
}
.pub-text-item {
  position: absolute;
  transform: translate(-50%, -50%);
  font-family: var(--font-display);
  font-weight: 900;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-red);
  text-shadow:
    -2px -2px 0 #000,  0 -2px 0 #000,  2px -2px 0 #000,
     2px  0   0 #000,  2px  2px 0 #000,  0  2px 0 #000,
    -2px  2px 0 #000, -2px  0   0 #000;
}
</style>
</head>
<body>

<!-- ── INTRO ── -->
<div id="intro-overlay">
  <h1 class="intro-heading">The truth is<br>out there</h1>
  <p class="intro-sub">You have 60 seconds. Construct your theory.</p>
  <button class="intro-btn" id="intro-begin">Begin</button>
</div>

<!-- ── PUBLISH ── -->
<div id="publish-overlay">
  <div id="publish-title-card">
    <div class="pub-card-title" id="pub-card-title">Narrative<br>Construction Kit</div>
    <div class="pub-card-sub" id="pub-card-sub">A user theory</div>
  </div>
  <video id="publish-video" playsinline></video>
  <div id="publish-text-container"></div>
  <button id="publish-close">✕ Close</button>
</div>

<div class="layout">
  <!-- ── SIDEBAR ── -->
  <div class="sidebar">
    <div class="category-tabs">
      <button class="cat-tab active" data-cat="ALL">All</button>
      <button class="cat-tab" data-cat="AUTHORITY">Authority</button>
      <button class="cat-tab" data-cat="EVIDENCE">Evidence</button>
      <button class="cat-tab" data-cat="SECRET">The Secret</button>
      <button class="cat-tab" data-cat="ORDINARY">Ordinary</button>
      <button class="cat-tab" data-cat="REACTION">Reaction</button>
    </div>

    <div class="search-bar">
      <div class="search-input-wrapper">
        <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <input type="text" placeholder="Search media" id="search-input">
      </div>
    </div>

    <div class="clip-preview-section">
      <div class="clip-preview-container" id="clip-preview-container">
        <video id="clip-player" style="display:none;"></video>
      </div>
      <div class="clip-scrubber" id="clip-scrubber">
        <div class="clip-scrubber-fill" id="clip-scrubber-fill"></div>
      </div>
    </div>

    <div class="sidebar-scroll">
      <div class="media-grid" id="media-grid"></div>
      <div class="text-stamps-section">
        <div class="section-label">Text layers</div>
        <select class="stamp-select" id="stamp-select">
          <option value="COINCIDENCE?">COINCIDENCE?</option>
          <option value="WHAT ARE THEY HIDING?">WHAT ARE THEY HIDING?</option>
          <option value="EXPOSED">EXPOSED</option>
          <option value="FOLLOW THE MONEY">FOLLOW THE MONEY</option>
          <option value="THEY KNEW">THEY KNEW</option>
          <option value="ASK YOURSELF WHY">ASK YOURSELF WHY</option>
          <option value="LOOK CLOSER">LOOK CLOSER</option>
          <option value="WAKE UP">WAKE UP</option>
          <option value="THE TRUTH IS OUT THERE!">THE TRUTH IS OUT THERE!</option>
        </select>
        <div class="stamp" id="active-stamp" data-stamp="COINCIDENCE?">COINCIDENCE?</div>
      </div>
    </div>
  </div>

  <!-- ── MAIN ── -->
  <div class="main-area">
    <div class="main-header">
      <div class="app-title">Narrative Construction Kit</div>
      <button class="publish-btn" id="publish-btn">Publish your theory</button>
    </div>

    <div class="tl-preview-section" id="tl-preview-section">
      <div class="tl-preview-container" id="tl-preview-container">
        <span class="preview-placeholder" id="tl-placeholder">Timeline preview</span>
        <video id="timeline-player" style="display:none;"></video>
        <div id="tl-text-container"></div>
      </div>
    </div>

    <div class="controls">
      <button class="ctrl-btn" id="btn-back" title="Back 5s">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <polygon points="12,4 3,12 12,20" fill="#d2d5e0"/>
          <polygon points="21,4 12,12 21,20" fill="#d2d5e0"/>
        </svg>
      </button>
      <button class="ctrl-btn play-pause" id="btn-play" title="Play / Pause">
        <svg width="26" height="26" viewBox="0 0 36 36" fill="none" id="play-icon">
          <polygon points="8,4 8,32 30,18" fill="#d2d5e0"/>
        </svg>
      </button>
      <button class="ctrl-btn" id="btn-fwd" title="Forward 5s">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <polygon points="12,4 21,12 12,20" fill="#d2d5e0"/>
          <polygon points="3,4 12,12 3,20" fill="#d2d5e0"/>
        </svg>
      </button>
    </div>

    <div class="timeline">
      <div class="timeline-header">
        <div class="time-counter" id="time-counter"><span class="used">0</span> / 60s</div>
      </div>

      <!-- Text clip size control — shows when text clip selected -->
      <div id="text-props" class="hidden">
        <span class="text-props-label" id="text-props-label">TEXT</span>
        <div class="text-props-size">
          <span class="size-label">Size</span>
          <button class="size-btn" id="text-size-down">−</button>
          <span class="size-val" id="text-size-val">48px</span>
          <button class="size-btn" id="text-size-up">+</button>
        </div>
      </div>

      <div class="timeline-body">
        <div class="playhead" id="playhead"></div>
        <div class="ruler" id="ruler"><canvas id="ruler-canvas"></canvas></div>
        <div class="tracks-container" id="tracks-container"></div>
      </div>
      <button class="add-track-btn" id="add-track-btn">+</button>
    </div>
  </div>
</div>

<script>
/* ─────────────────────────────────────────
   CONSTANTS
───────────────────────────────────────── */
const MAX_DUR   = 60;
const TEXT_DUR  = 5;
const FONT_DEF  = 48;
const FONT_MIN  = 20;
const FONT_MAX  = 96;
const FONT_STEP = 8;

// Grey-blue clip colours
const CLIP_COLORS = [
  '#2e3348','#353a50','#2b3245','#3c4158','#333854',
  '#2d3449','#3a3f54','#31364e','#3e4358','#303650'
];
let colorIdx = 0;

/* ─────────────────────────────────────────
   REFS
───────────────────────────────────────── */
const clipPlayer      = document.getElementById('clip-player');
const clipScrubber    = document.getElementById('clip-scrubber');
const clipScrubFill   = document.getElementById('clip-scrubber-fill');
const clipPreviewCont = document.getElementById('clip-preview-container');
const tlPlayer        = document.getElementById('timeline-player');
const tlPlaceholder   = document.getElementById('tl-placeholder');
const tlTextCont      = document.getElementById('tl-text-container');
const tlPreviewCont   = document.getElementById('tl-preview-container');
const searchInput     = document.getElementById('search-input');
const mediaGrid       = document.getElementById('media-grid');
const btnPlay         = document.getElementById('btn-play');
const playIcon        = document.getElementById('play-icon');
const btnBack         = document.getElementById('btn-back');
const btnFwd          = document.getElementById('btn-fwd');
const ruler           = document.getElementById('ruler');
const rulerCanvas     = document.getElementById('ruler-canvas');
const rCtx            = rulerCanvas.getContext('2d');
const playhead        = document.getElementById('playhead');
const tracksCont      = document.getElementById('tracks-container');
const addTrackBtn     = document.getElementById('add-track-btn');
const timeCounter     = document.getElementById('time-counter');
const textProps       = document.getElementById('text-props');
const textPropsLabel  = document.getElementById('text-props-label');
const textSizeVal     = document.getElementById('text-size-val');

const getTracks = () => document.querySelectorAll('.track');

/* ─────────────────────────────────────────
   STATE
───────────────────────────────────────── */
let trackCount   = 0;
let clips        = [];       // all clips (video + text)
let playing      = false;
let playTime     = 0;
let lastRaf      = 0;
let activeVid    = null;
let pendingSeek  = null;
let tlSrc        = '';
let selIds       = new Set();
let assetMeta    = {};
let activeCat    = 'ALL';

// Live text overlay elements (clipId → DOM el)
const textEls = new Map();

/* ─────────────────────────────────────────
   UNDO
───────────────────────────────────────── */
const undo$ = [];
const pushUndo = () => { undo$.push(JSON.stringify(clips)); if (undo$.length > 50) undo$.shift(); };
const undo = () => {
  if (!undo$.length) return;
  clips = JSON.parse(undo$.pop());
  selIds.clear(); renderClips(); updateCounter(); updateTextProps(); syncPreview();
};

/* ─────────────────────────────────────────
   INTRO
───────────────────────────────────────── */
document.getElementById('intro-begin').addEventListener('click', () => {
  const o = document.getElementById('intro-overlay');
  o.classList.add('dismissing');
  o.addEventListener('animationend', () => o.remove(), { once: true });
});

/* ─────────────────────────────────────────
   CATEGORY TABS
───────────────────────────────────────── */
document.querySelectorAll('.cat-tab').forEach(t => t.addEventListener('click', () => {
  document.querySelectorAll('.cat-tab').forEach(x => x.classList.remove('active'));
  t.classList.add('active'); activeCat = t.dataset.cat; filterGrid();
}));
function filterGrid() {
  const q = searchInput.value.trim().toLowerCase();
  document.querySelectorAll('#media-grid .card').forEach(c => {
    const catOk  = activeCat === 'ALL' || c.dataset.category === activeCat;
    const srchOk = !q || (c.dataset.label||'').toLowerCase().includes(q);
    c.classList.toggle('hidden', !catOk || !srchOk);
  });
}
searchInput.addEventListener('input', filterGrid);
searchInput.addEventListener('keydown', e => e.stopPropagation());

/* ─────────────────────────────────────────
   COUNTER
───────────────────────────────────────── */
function updateCounter() {
  let max = 0;
  clips.forEach(c => { max = Math.max(max, c.start + c.duration); });
  const used = Math.min(Math.round(max), MAX_DUR);
  timeCounter.innerHTML = `<span class="used">${used}</span> / 60s`;
}

/* ─────────────────────────────────────────
   TEXT PROPS BAR
───────────────────────────────────────── */
function updateTextProps() {
  if (selIds.size !== 1) { textProps.classList.add('hidden'); return; }
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') { textProps.classList.add('hidden'); return; }
  textProps.classList.remove('hidden');
  textPropsLabel.textContent = clip.text;
  textSizeVal.textContent = clip.fontSize + 'px';
}
document.getElementById('text-size-down').addEventListener('click', () => {
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') return;
  clip.fontSize = Math.max(FONT_MIN, clip.fontSize - FONT_STEP);
  textSizeVal.textContent = clip.fontSize + 'px';
  updateTextOverlays(playTime);
});
document.getElementById('text-size-up').addEventListener('click', () => {
  const clip = clips.find(c => c.id === [...selIds][0]);
  if (!clip || clip.type !== 'text') return;
  clip.fontSize = Math.min(FONT_MAX, clip.fontSize + FONT_STEP);
  textSizeVal.textContent = clip.fontSize + 'px';
  updateTextOverlays(playTime);
});

/* ─────────────────────────────────────────
   TRACK MANAGEMENT
───────────────────────────────────────── */
function createTrack() {
  const idx   = trackCount++;
  const total = getTracks().length + 1;
  const track = document.createElement('div');
  track.className = 'track'; track.dataset.track = idx;

  // Layer label (top = layer 1, highest priority)
  const lbl = document.createElement('span');
  lbl.className = 'track-label';
  lbl.textContent = `L${total}`;
  lbl.dataset.labelFor = idx;

  const clipArea = document.createElement('div');
  clipArea.className = 'track-clips'; clipArea.dataset.trackClips = idx;

  const rmBtn = document.createElement('button');
  rmBtn.className = 'track-remove'; rmBtn.innerHTML = '&minus;';
  rmBtn.addEventListener('click', e => { e.stopPropagation(); removeTrack(idx); });

  track.appendChild(lbl); track.appendChild(clipArea); track.appendChild(rmBtn);
  tracksCont.appendChild(track);
  updateTrackButtons(); relabelTracks(); return track;
}

function relabelTracks() {
  const tracks = getTracks();
  tracks.forEach((t, i) => {
    const lbl = t.querySelector('.track-label');
    if (lbl) lbl.textContent = `L${i+1}`;
  });
}

function removeTrack(idx) {
  if (getTracks().length <= 1) return;
  if (clips.some(c => c.track === idx)) return;
  document.querySelector(`.track[data-track="${idx}"]`)?.remove();
  updateTrackButtons(); relabelTracks();
}

function updateTrackButtons() {
  getTracks().forEach(t => {
    const idx = parseInt(t.dataset.track);
    const btn = t.querySelector('.track-remove');
    if (btn) btn.style.display = (!clips.some(c => c.track === idx) && getTracks().length > 1) ? 'flex' : 'none';
  });
}

createTrack(); createTrack(); createTrack();
addTrackBtn.addEventListener('click', createTrack);

/* ─────────────────────────────────────────
   CLIP PREVIEW (LEFT PANEL)
───────────────────────────────────────── */
clipPreviewCont.addEventListener('mousedown', e => {
  if (!clipPlayer.duration) return; e.preventDefault();
  const sx = e.clientX; let scrub = false;
  const onMove = e2 => {
    if (!scrub && Math.abs(e2.clientX - sx) > 3) { scrub = true; clipPlayer.pause(); }
    if (scrub) {
      const r = clipPreviewCont.getBoundingClientRect();
      const p = Math.max(0, Math.min(1, (e2.clientX - r.left) / r.width));
      clipPlayer.currentTime = p * clipPlayer.duration; clipScrubFill.style.width = p*100+'%';
    }
  };
  const onUp = () => {
    document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
    if (!scrub) clipPlayer.paused ? clipPlayer.play() : clipPlayer.pause();
  };
  document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
});

clipScrubber.addEventListener('mousedown', e => {
  const seek = e2 => {
    if (!clipPlayer.duration) return;
    const r = clipScrubber.getBoundingClientRect();
    const p = Math.max(0, Math.min(1, (e2.clientX - r.left) / r.width));
    clipPlayer.currentTime = p * clipPlayer.duration; clipScrubFill.style.width = p*100+'%';
  };
  seek(e);
  const up = () => { document.removeEventListener('mousemove', seek); document.removeEventListener('mouseup', up); };
  document.addEventListener('mousemove', seek); document.addEventListener('mouseup', up);
});

clipPlayer.addEventListener('timeupdate', () => {
  if (clipPlayer.duration) clipScrubFill.style.width = clipPlayer.currentTime/clipPlayer.duration*100+'%';
});
clipPlayer.addEventListener('ended', () => { clipScrubFill.style.width = '100%'; });

/* ─────────────────────────────────────────
   THUMBNAILS
───────────────────────────────────────── */
function generateThumb(card) {
  const v = document.createElement('video');
  v.preload = 'metadata'; v.muted = true; v.src = card.dataset.src;
  v.addEventListener('loadedmetadata', () => { v.currentTime = v.duration*(0.2+Math.random()*0.3); card.dataset.duration = v.duration; });
  v.addEventListener('seeked', () => {
    const c = card.querySelector('.card-thumb');
    c.width = v.videoWidth; c.height = v.videoHeight;
    c.getContext('2d').drawImage(v, 0, 0, c.width, c.height);
    v.src=''; v.load();
  });
}

/* ─────────────────────────────────────────
   CARD SETUP
───────────────────────────────────────── */
function setupCard(card) {
  card.addEventListener('click', () => {
    document.querySelectorAll('#media-grid .card').forEach(c => c.classList.remove('active'));
    card.classList.add('active');
    clipPlayer.style.display = 'block';
    clipPlayer.src = card.dataset.src; clipPlayer.play();
    clipScrubFill.style.width = '0%';
  });
  card.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const sx = e.clientX, sy = e.clientY;
    let drag = false, ghost = null;
    const data = { src: card.dataset.src, label: card.dataset.label, duration: parseFloat(card.dataset.duration)||30 };
    const onMove = e2 => {
      if (!drag && (Math.abs(e2.clientX-sx)>5 || Math.abs(e2.clientY-sy)>5)) {
        drag = true; ghost = mkGhost(data.label, 'drag-ghost'); document.body.appendChild(ghost);
      }
      if (drag && ghost) {
        posGhost(ghost, e2);
        getTracks().forEach(t => t.classList.remove('drag-over'));
        e2.target?.closest?.('.track')?.classList.add('drag-over');
      }
    };
    const onUp = e2 => {
      document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
      ghost?.remove(); getTracks().forEach(t => t.classList.remove('drag-over'));
      if (drag) {
        const clipArea = e2.target?.closest?.('.track-clips');
        if (clipArea) {
          const trackIdx = parseInt(clipArea.dataset.trackClips);
          const r = clipArea.getBoundingClientRect();
          const t = Math.max(0, Math.min((e2.clientX-r.left)/r.width*MAX_DUR, MAX_DUR-0.5));
          const d = Math.min(data.duration, MAX_DUR-t);
          if (d > 0.5) addVideoClip(trackIdx, t, d, data.src, data.label, data.duration);
        }
      }
    };
    document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
  });
}

/* ─────────────────────────────────────────
   STAMP DRAG → TEXT LAYER CLIP
───────────────────────────────────────── */
document.getElementById('stamp-select').addEventListener('change', e => {
  const el = document.getElementById('active-stamp');
  el.dataset.stamp = e.target.value;
  el.textContent = e.target.value;
});

document.querySelectorAll('.stamp').forEach(stamp => {
  stamp.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const sx = e.clientX, sy = e.clientY;
    const text = stamp.dataset.stamp;
    let drag = false, ghost = null;
    const onMove = e2 => {
      if (!drag && (Math.abs(e2.clientX-sx)>5 || Math.abs(e2.clientY-sy)>5)) {
        drag = true; ghost = mkGhost(text, 'stamp-ghost'); document.body.appendChild(ghost);
      }
      if (drag && ghost) {
        posGhost(ghost, e2);
        getTracks().forEach(t => t.classList.remove('drag-over'));
        e2.target?.closest?.('.track')?.classList.add('drag-over');
      }
    };
    const onUp = e2 => {
      document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
      ghost?.remove(); getTracks().forEach(t => t.classList.remove('drag-over'));
      if (drag) {
        const clipArea = e2.target?.closest?.('.track-clips');
        if (clipArea) {
          const trackIdx = parseInt(clipArea.dataset.trackClips);
          const r = clipArea.getBoundingClientRect();
          const t = Math.max(0, Math.min((e2.clientX-r.left)/r.width*MAX_DUR, MAX_DUR-TEXT_DUR));
          addTextClip(trackIdx, t, text);
        }
      }
    };
    document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
  });
});

function mkGhost(text, cls) { const d = document.createElement('div'); d.className = cls; d.textContent = text; return d; }
function posGhost(g, e) { g.style.left = e.clientX+12+'px'; g.style.top = e.clientY-16+'px'; }

/* ─────────────────────────────────────────
   MEDIA LIBRARY
───────────────────────────────────────── */
const FALLBACK = [
  '40k end up in morgues.mp4','a_bomb.mp4','come stay in this hotel.mp4',
  'enemy would like.mp4','lesbian implications.mp4','psychiatrists believe.mp4',
  'sign of a poorly-balanced economy.mp4','through the mouth and nose.mp4',
  'traffic signs.mp4','where does pollution come from.mp4'
];
async function loadMeta() { try { const r=await fetch('Assets/metadata.json'); return r.ok?await r.json():{}; } catch { return {}; } }
async function scanAssets() {
  try {
    const r = await fetch('Assets/'); if (!r.ok) return [];
    const doc = new DOMParser().parseFromString(await r.text(),'text/html');
    const files = [];
    doc.querySelectorAll('a').forEach(a => {
      const h = a.getAttribute('href');
      if (h && /\.mp4$/i.test(h)) {
        const raw = h.split('/').pop(), dec = decodeURIComponent(raw);
        files.push({ src:'Assets/'+raw, label: dec.replace(/\.mp4$/i,'').replace(/[_-]/g,' '), filename: dec });
      }
    });
    return files;
  } catch { return []; }
}
function buildList(names) {
  return names.map(f => ({ src:'Assets/'+encodeURIComponent(f), label:f.replace(/\.mp4$/i,'').replace(/[_-]/g,' '), filename:f }));
}
function addCard(f) {
  const card = document.createElement('div');
  card.className='card'; card.dataset.src=f.src;
  card.dataset.label = f.label.toLowerCase();
  card.dataset.category = assetMeta[f.filename]||'ALL';
  const canvas = document.createElement('canvas'); canvas.className='card-thumb'; card.appendChild(canvas);
  const lbl = document.createElement('div'); lbl.className='card-label'; lbl.textContent=f.label; card.appendChild(lbl);
  mediaGrid.appendChild(card); generateThumb(card); setupCard(card);
}
async function loadLibrary() {
  assetMeta = await loadMeta();
  let files = await scanAssets();
  if (!files.length) files = buildList(FALLBACK);
  files.sort((a,b)=>a.label.localeCompare(b.label));
  files.forEach(addCard);
  filterGrid(); // Re-apply active filter after all cards are in the DOM
}

/* ─────────────────────────────────────────
   CLIP CREATION
───────────────────────────────────────── */
function addVideoClip(track, start, dur, src, label, srcDur) {
  const s = Math.max(0, start);
  const d = Math.min(dur, MAX_DUR - start);
  if (d <= 0.5 || wouldOverlap(track, s, d)) return; // reject overlap
  pushUndo();
  clips.push({
    id: Date.now()+Math.random(), type:'video', track,
    start: s, duration: d,
    src, label, srcDuration:srcDur, srcOffset:0,
    color: CLIP_COLORS[colorIdx++ % CLIP_COLORS.length]
  });
  renderClips(); drawRuler(); syncPreview(); updateCounter();
}
function addTextClip(track, start, text) {
  const clipStart = Math.max(0, start);
  const clipDur   = Math.min(TEXT_DUR, MAX_DUR - start);
  if (wouldOverlap(track, clipStart, clipDur)) return; // reject overlap
  pushUndo();
  clips.push({
    id: Date.now()+Math.random(), type:'text', track,
    start: clipStart, duration: clipDur,
    text, fontSize:FONT_DEF, textX:50, textY:75
  });
  if (playTime < clipStart || playTime >= clipStart + clipDur) {
    playTime = clipStart;
    updatePlayhead();
  }
  renderClips(); drawRuler(); syncPreview(); updateCounter();
}

/* ─────────────────────────────────────────
   OVERLAP HELPERS
───────────────────────────────────────── */
function wouldOverlap(track, start, duration, excludeId = null) {
  return clips.some(c =>
    c.id !== excludeId &&
    c.track === track &&
    start < c.start + c.duration &&
    start + duration > c.start
  );
}

// Snap-to-edge: returns the nearest valid start position for a clip,
// snapping to the adjacent clip's edge rather than freezing in place.
function clampDragStart(clip, desired) {
  const raw = Math.max(0, Math.min(MAX_DUR - clip.duration, desired));
  const peers = clips.filter(c => c.id !== clip.id && c.track === clip.track);
  let result = raw;
  for (const p of peers) {
    if (result < p.start + p.duration && result + clip.duration > p.start) {
      // Snap to whichever edge is closer
      result = desired >= p.start ? p.start + p.duration : p.start - clip.duration;
    }
  }
  return Math.max(0, Math.min(MAX_DUR - clip.duration, result));
}

/* ─────────────────────────────────────────
   RENDER CLIPS
───────────────────────────────────────── */
function renderClips() {
  document.querySelectorAll('.clip').forEach(el => el.remove());
  clips.forEach(clip => {
    const clipArea = document.querySelector(`.track-clips[data-track-clips="${clip.track}"]`);
    if (!clipArea) return;
    const isText = clip.type === 'text';
    const el = document.createElement('div');
    el.className = 'clip' + (isText?' clip-text':'') + (selIds.has(clip.id)?' selected':'');
    el.dataset.clipId = clip.id;
    el.style.left  = (clip.start    / MAX_DUR * 100) + '%';
    el.style.width = (clip.duration / MAX_DUR * 100) + '%';
    if (!isText) el.style.background = clip.color;

    const hL = document.createElement('div'); hL.className='clip-handle left';
    const hR = document.createElement('div'); hR.className='clip-handle right';
    const lbl = document.createElement('span'); lbl.className='clip-label';
    lbl.textContent = isText ? clip.text : clip.label;
    if (isText) { lbl.style.fontFamily='var(--font-display)'; lbl.style.fontSize='8px'; lbl.style.textAlign='center'; lbl.style.width='100%'; }

    el.appendChild(hL); el.appendChild(lbl); el.appendChild(hR);
    clipArea.appendChild(el);

    el.addEventListener('click', e => {
      e.stopPropagation();
      if (e.shiftKey||e.metaKey||e.ctrlKey) { selIds.has(clip.id)?selIds.delete(clip.id):selIds.add(clip.id); }
      else { if (selIds.has(clip.id)&&selIds.size===1) selIds.clear(); else { selIds.clear(); selIds.add(clip.id); } }
      renderClips(); updateTextProps();
    });
    setupClipDrag(el, clip, clipArea);
    setupResize(hL, clip, 'left', clipArea);
    setupResize(hR, clip, 'right', clipArea);
  });
  updateTrackButtons();
}

function setupClipDrag(el, clip, clipArea) {
  el.addEventListener('mousedown', e => {
    if (e.target.classList.contains('clip-handle')) return;
    e.stopPropagation(); e.preventDefault();
    const sx = e.clientX, os = clip.start; let pushed = false;
    const onMove = e2 => {
      if (!pushed) { pushUndo(); pushed=true; }
      const rRect = ruler.getBoundingClientRect();
      const desired = os + ((e2.clientX - sx) / rRect.width) * MAX_DUR;
      const newArea = e2.target?.closest?.('.track-clips');
      if (newArea) clip.track = parseInt(newArea.dataset.trackClips);
      clip.start = clampDragStart(clip, desired);
      renderClips(); updateCounter();
    };
    const onUp = () => { document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

function setupResize(handle, clip, side, clipArea) {
  handle.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault(); pushUndo();
    const sx=e.clientX, os=clip.start, od=clip.duration, oo=clip.srcOffset||0;
    handle.classList.add('dragging');
    const onMove = e2 => {
      const dt = ((e2.clientX-sx)/ruler.getBoundingClientRect().width)*MAX_DUR;
      if (side==='left') {
        const ns = Math.max(0, os+dt);
        const d  = ns - os;
        const nd = od - d;
        const newOffset = oo + d;
        // Reject: too short, would go before source start, or would overlap a peer
        if (nd > 0.5 && (clip.type==='text' || newOffset >= 0) && !wouldOverlap(clip.track, ns, nd, clip.id)) {
          clip.start = ns; clip.duration = nd;
          if (clip.type !== 'text') clip.srcOffset = newOffset;
        }
      } else {
        const maxD = clip.type==='text' ? MAX_DUR-clip.start : Math.min(clip.srcDuration-oo, MAX_DUR-clip.start);
        const newDur = Math.max(0.5, Math.min(od+dt, maxD));
        if (!wouldOverlap(clip.track, clip.start, newDur, clip.id)) {
          clip.duration = newDur;
        }
      }
      renderClips(); updateCounter();
    };
    const onUp = () => { handle.classList.remove('dragging'); document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

/* ─────────────────────────────────────────
   TEXT OVERLAY (PREVIEW) — DRAGGABLE
───────────────────────────────────────── */
function getActiveTextClips(t) {
  return clips
    .filter(c => c.type==='text' && t>=c.start && t<c.start+c.duration)
    .sort((a,b) => b.track - a.track); // highest track idx = lowest layer (bottom render)
}

function updateTextOverlays(t) {
  const active = getActiveTextClips(t);
  const activeIds = new Set(active.map(c=>c.id));

  // Remove stale
  for (const [id, el] of textEls) {
    if (!activeIds.has(id)) { el.remove(); textEls.delete(id); }
  }
  // Add / update
  active.forEach(clip => {
    let el = textEls.get(clip.id);
    if (!el) {
      el = document.createElement('div');
      el.className = 'tl-text-item';
      tlTextCont.appendChild(el);
      textEls.set(clip.id, el);
      setupTextDrag(el, clip);
    }
    el.textContent = clip.text;
    el.style.fontSize = clip.fontSize + 'px';
    el.style.left = (clip.textX ?? 50) + '%';
    el.style.top  = (clip.textY ?? 75) + '%';
  });
}

function setupTextDrag(el, clip) {
  el.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault();
    const rect = tlPreviewCont.getBoundingClientRect();
    const sx = e.clientX, sy = e.clientY;
    const ox = clip.textX ?? 50, oy = clip.textY ?? 75;
    const onMove = e2 => {
      clip.textX = Math.max(0, Math.min(100, ox + ((e2.clientX-sx)/rect.width)*100));
      clip.textY = Math.max(0, Math.min(100, oy + ((e2.clientY-sy)/rect.height)*100));
      el.style.left = clip.textX + '%';
      el.style.top  = clip.textY + '%';
    };
    const onUp = () => { document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); };
    document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
}

/* ─────────────────────────────────────────
   PREVIEW SYNC
───────────────────────────────────────── */
function getVideoAt(t) {
  // Lower track index = higher layer priority (track 0 = top)
  let best = null;
  for (const c of clips) {
    if (c.type!=='video') continue;
    if (t>=c.start && t<c.start+c.duration) {
      if (!best || c.track < best.track) best = c;
    }
  }
  return best;
}

function syncPreview() {
  const vClip = getVideoAt(playTime);
  if (vClip) {
    tlPlaceholder.style.display = 'none'; tlPlayer.style.display = 'block';
    const tgt = vClip.srcOffset + (playTime - vClip.start);
    if (tlSrc === vClip.src) {
      tlPlayer.currentTime = tgt;
      if (playing && tlPlayer.paused) tlPlayer.play();
      activeVid = vClip;
    } else {
      tlPlayer.pause(); pendingSeek = vClip; tlSrc = vClip.src;
      tlPlayer.src = vClip.src; tlPlayer.load(); activeVid = vClip;
    }
  } else {
    tlPlayer.pause(); activeVid = null;
    if (!getActiveTextClips(playTime).length) { tlPlaceholder.style.display=''; tlPlayer.style.display='none'; }
    else tlPlaceholder.style.display='none';
  }
  updateTextOverlays(playTime);
}

tlPlayer.addEventListener('loadeddata', () => {
  if (pendingSeek) {
    const c = pendingSeek; pendingSeek = null;
    tlPlayer.currentTime = Math.max(0, c.srcOffset+(playTime-c.start));
    if (playing) tlPlayer.play();
  }
});

tlPlayer.addEventListener('ended', () => {
  // Video finished — advance playTime past the clip so tick picks up the next one
  if (playing && activeVid) {
    playTime = activeVid.start + activeVid.duration;
    activeVid = null;
    syncPreview();
  }
});

/* ─────────────────────────────────────────
   PLAYBACK
───────────────────────────────────────── */
function setPlayIcon(showPlay) {
  playIcon.innerHTML = showPlay
    ? '<polygon points="8,4 8,32 30,18" fill="#d2d5e0"/>'
    : '<rect x="7" y="5" width="7" height="26" rx="1" fill="#d2d5e0"/><rect x="22" y="5" width="7" height="26" rx="1" fill="#d2d5e0"/>';
}
btnPlay.addEventListener('click', () => playing ? stop() : start());
btnBack.addEventListener('click', () => { playTime=Math.max(0,playTime-5); updatePlayhead(); syncPreview(); });
btnFwd.addEventListener('click',  () => { playTime=Math.min(MAX_DUR,playTime+5); updatePlayhead(); syncPreview(); });

function start() {
  if (!clips.length) return;
  playing=true; setPlayIcon(false); lastRaf=performance.now(); syncPreview(); requestAnimationFrame(tick);
}
function stop() { playing=false; setPlayIcon(true); tlPlayer.pause(); activeVid=null; }

function tick(now) {
  if (!playing) return;
  const dt = (now - lastRaf) / 1000;
  lastRaf = now;

  // Derive playTime from video when playing — prevents wall-clock drift
  if (activeVid && !tlPlayer.paused && !tlPlayer.seeking && !tlPlayer.ended) {
    playTime = activeVid.start + (tlPlayer.currentTime - activeVid.srcOffset);
  } else {
    playTime += dt;
  }

  if (playTime >= MAX_DUR) { playTime=0; stop(); updatePlayhead(); return; }
  updatePlayhead();
  if (getVideoAt(playTime) !== activeVid) syncPreview();
  else updateTextOverlays(playTime);
  requestAnimationFrame(tick);
}

/* ─────────────────────────────────────────
   RULER
───────────────────────────────────────── */
function drawRuler() {
  const dpr = window.devicePixelRatio||1;
  const r   = rulerCanvas.getBoundingClientRect();
  rulerCanvas.width=r.width*dpr; rulerCanvas.height=r.height*dpr;
  rCtx.scale(dpr,dpr); rCtx.clearRect(0,0,r.width,r.height);

  const step = (() => { const raw=MAX_DUR/(r.width/40); for (const s of[1,2,5,10,15,30,60]) if(s>=raw) return s; return 60; })();
  for (let i=0; i<=Math.floor(MAX_DUR/step); i++) {
    const t=i*step, x=(t/MAX_DUR)*r.width, maj=i%5===0;
    rCtx.beginPath(); rCtx.moveTo(x,maj?4:14); rCtx.lineTo(x,r.height);
    rCtx.strokeStyle=maj?'#22252e':'#191c24'; rCtx.lineWidth=1; rCtx.stroke();
    if (maj) {
      rCtx.fillStyle='#4a4e5e'; rCtx.font='8px "Space Mono",monospace';
      rCtx.textAlign='left'; rCtx.fillText(Math.floor(t/60)+':'+(t%60).toString().padStart(2,'0'), x+3, 11);
    }
  }
  // 60s cap
  rCtx.beginPath(); rCtx.moveTo(r.width-1,0); rCtx.lineTo(r.width-1,r.height);
  rCtx.strokeStyle='rgba(190,194,212,0.45)'; rCtx.lineWidth=2; rCtx.stroke();
  rCtx.fillStyle='rgba(190,194,212,0.6)'; rCtx.font='bold 8px "Space Mono",monospace';
  rCtx.textAlign='right'; rCtx.fillText('60s', r.width-3, 11); rCtx.textAlign='left';
}

function updatePlayhead() {
  const bodyW = playhead.parentElement.offsetWidth;
  const px = 52 + (playTime / MAX_DUR) * (bodyW - 52);
  playhead.style.left = px + 'px';
}

ruler.addEventListener('mousedown', e => {
  const seek = e2 => {
    const rect=ruler.getBoundingClientRect();
    playTime=Math.max(0,Math.min(1,(e2.clientX-rect.left)/rect.width))*MAX_DUR;
    updatePlayhead(); syncPreview();
  };
  seek(e);
  const up=()=>{ document.removeEventListener('mousemove',seek); document.removeEventListener('mouseup',up); };
  document.addEventListener('mousemove',seek); document.addEventListener('mouseup',up);
});

tracksCont.addEventListener('click', () => {
  if (selIds.size) { selIds.clear(); renderClips(); updateTextProps(); }
});

/* ─────────────────────────────────────────
   KEYBOARD
───────────────────────────────────────── */
document.addEventListener('keydown', e => {
  if (document.getElementById('intro-overlay')) return;
  if (e.code==='Space') { e.preventDefault(); btnPlay.click(); }
  if ((e.code==='Backspace'||e.code==='Delete') && selIds.size) {
    e.preventDefault(); pushUndo();
    clips = clips.filter(c=>!selIds.has(c.id));
    selIds.clear(); renderClips(); drawRuler(); syncPreview(); updateCounter(); updateTextProps();
  }
  if (e.code==='KeyZ'&&(e.metaKey||e.ctrlKey)&&!e.shiftKey) { e.preventDefault(); undo(); }
  if (e.code==='Escape') { const po=document.getElementById('publish-overlay'); if(po.classList.contains('active')) endPublish(); }
});

/* ─────────────────────────────────────────
   PUBLISH
───────────────────────────────────────── */
const pubOverlay   = document.getElementById('publish-overlay');
const pubVideo     = document.getElementById('publish-video');
const pubTitleCard = document.getElementById('publish-title-card');
const pubCardTitle = document.getElementById('pub-card-title');
const pubCardSub   = document.getElementById('pub-card-sub');
const pubTextCont  = document.getElementById('publish-text-container');

let pubActive=false, pubTimer=null, pubRAF=null, pubTime=0, pubLast=0;
let pubVidSrc='', pubVidClip=null;

document.getElementById('publish-btn').addEventListener('click', () => {
  if (!clips.length) return;
  pubActive=true; pubTime=0; pubVidSrc=''; pubVidClip=null;
  pubOverlay.classList.add('active');
  pubVideo.style.display='none'; pubTextCont.innerHTML='';
  showPubCard('Narrative<br>Construction Kit','A user theory',3000, startPub);
});
function showPubCard(title,sub,dur,cb) {
  pubCardTitle.innerHTML=title; pubCardSub.textContent=sub;
  pubTitleCard.style.display='flex'; pubVideo.style.display='none'; pubTextCont.innerHTML='';
  requestAnimationFrame(()=>requestAnimationFrame(()=>pubTitleCard.classList.add('visible')));
  pubTimer=setTimeout(()=>{
    pubTitleCard.classList.remove('visible');
    setTimeout(()=>{ pubTitleCard.style.display='none'; if(pubActive&&cb) cb(); },850);
  },dur);
}
function startPub() {
  if (!pubActive) return;
  pubTime=0; pubLast=performance.now();
  pubVideo.style.display='block';
  pubRAF=requestAnimationFrame(pubTick);
}
function pubTick(now) {
  if (!pubActive) return;
  pubTime += (now-pubLast)/1000; pubLast=now;
  if (pubTime>=MAX_DUR) {
    pubVideo.pause(); pubVideo.style.display='none'; pubTextCont.innerHTML='';
    showPubCard('The truth is<br>out there','Theory complete',5000,null); return;
  }
  const vClip = getVideoAt(pubTime);
  if (vClip) {
    if (pubVidClip!==vClip) {
      pubVidClip=vClip;
      if (pubVidSrc!==vClip.src) { pubVidSrc=vClip.src; pubVideo.src=vClip.src; pubVideo.play(); }
      pubVideo.currentTime=vClip.srcOffset+(pubTime-vClip.start);
      if (pubVideo.paused) pubVideo.play();
    }
  } else { if (!pubVideo.paused) pubVideo.pause(); }

  // Text overlays
  const tClips = getActiveTextClips(pubTime);
  pubTextCont.innerHTML='';
  tClips.forEach(c => {
    const el=document.createElement('div'); el.className='pub-text-item';
    el.textContent=c.text; el.style.fontSize=c.fontSize+'px';
    el.style.left=(c.textX??50)+'%'; el.style.top=(c.textY??75)+'%';
    pubTextCont.appendChild(el);
  });
  pubRAF=requestAnimationFrame(pubTick);
}
function endPublish() {
  pubActive=false; clearTimeout(pubTimer); cancelAnimationFrame(pubRAF);
  pubVideo.pause(); pubVideo.src=''; pubTextCont.innerHTML='';
  pubTitleCard.classList.remove('visible'); pubTitleCard.style.display='none';
  pubOverlay.classList.remove('active');
}
document.getElementById('publish-close').addEventListener('click', endPublish);

/* ─────────────────────────────────────────
   INIT
───────────────────────────────────────── */
updatePlayhead(); updateCounter(); loadLibrary();
document.fonts.ready.then(()=>drawRuler());
window.addEventListener('resize', ()=>{ drawRuler(); renderClips(); });
</script>
</body>
</html>
