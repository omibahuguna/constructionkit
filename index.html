<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Narrative Construction Kit</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    height: 100%;
    overflow: hidden;
    background: #0a0a0a;
    font-family: 'Space Mono', monospace;
    color: #ccc;
  }

  /* ── INTRO OVERLAY ── */
  #intro-overlay {
    position: fixed;
    inset: 0;
    background: #080810;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 24px;
    animation: introFadeIn 1.4s ease forwards;
  }

  @keyframes introFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  #intro-overlay.dismissing {
    animation: introFadeOut 0.5s ease forwards;
    pointer-events: none;
  }

  @keyframes introFadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  .intro-heading {
    font-family: 'Orbitron', monospace;
    font-size: clamp(36px, 7vw, 88px);
    font-weight: 900;
    letter-spacing: 0.06em;
    color: #e8e8e8;
    text-align: center;
    line-height: 1.1;
    text-transform: uppercase;
    animation: textUp 1.2s 0.5s both;
  }

  .intro-sub {
    font-family: 'Space Mono', monospace;
    font-size: clamp(11px, 1.4vw, 15px);
    color: #555;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    text-align: center;
    animation: textUp 1.2s 0.8s both;
  }

  @keyframes textUp {
    from { opacity: 0; transform: translateY(18px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .intro-btn {
    margin-top: 20px;
    font-family: 'Orbitron', monospace;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.3em;
    color: #e8e8e8;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.25);
    padding: 14px 52px;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.2s, border-color 0.2s;
    animation: textUp 1.2s 1.1s both;
  }

  .intro-btn:hover {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.5);
  }

  /* ── LAYOUT ── */
  .layout {
    display: flex;
    height: 100vh;
  }

  /* ── SIDEBAR ── */
  .sidebar {
    width: 40%;
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Category tabs */
  .category-tabs {
    display: flex;
    overflow-x: auto;
    padding: 10px 12px 0;
    flex-shrink: 0;
    scrollbar-width: none;
    gap: 2px;
  }
  .category-tabs::-webkit-scrollbar { display: none; }

  .cat-tab {
    font-family: 'Space Mono', monospace;
    font-size: 8px;
    font-weight: 700;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #444;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    padding: 6px 9px 8px;
    cursor: pointer;
    white-space: nowrap;
    transition: color 0.15s, border-color 0.15s;
    flex-shrink: 0;
  }
  .cat-tab:hover { color: #888; }
  .cat-tab.active { color: #e8e8e8; border-bottom-color: #e84393; }

  /* Search */
  .search-bar { padding: 10px 12px; }

  .search-input-wrapper {
    display: flex;
    align-items: center;
    background: #0a0a0a;
    border-radius: 4px;
    padding: 10px 12px;
    gap: 10px;
  }

  .search-icon { flex-shrink: 0; width: 16px; height: 16px; opacity: 0.5; }

  .search-input-wrapper input {
    background: none;
    border: none;
    outline: none;
    color: #ccc;
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    width: 100%;
  }
  .search-input-wrapper input::placeholder { color: #444; }

  /* Clip preview */
  .clip-preview-section { flex-shrink: 0; }

  .clip-preview-container {
    background: #0a0a0a;
    display: flex;
    align-items: center;
    justify-content: center;
    aspect-ratio: 16 / 9;
    position: relative;
    cursor: pointer;
  }

  .clip-preview-container video {
    width: 100%; height: 100%;
    display: block; object-fit: contain;
    background: #0a0a0a;
  }

  .preview-placeholder {
    color: #2a2a3e;
    font-size: 10px;
    font-family: 'Space Mono', monospace;
    text-transform: uppercase;
    letter-spacing: 2px;
    position: absolute;
    pointer-events: none;
  }

  .clip-scrubber { height: 4px; background: #111; cursor: pointer; position: relative; }
  .clip-scrubber-fill { height: 100%; background: #e84393; width: 0%; pointer-events: none; }

  /* Scrollable media + stamps */
  .sidebar-scroll {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  .sidebar-scroll::-webkit-scrollbar { width: 4px; }
  .sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
  .sidebar-scroll::-webkit-scrollbar-thumb { background: #2a2a3e; border-radius: 2px; }

  .media-grid {
    padding: 12px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    align-content: start;
  }

  .card {
    background: #12121e;
    border-radius: 5px;
    padding: 8px;
    cursor: grab;
    transition: background 0.15s;
    user-select: none;
  }
  .card.hidden { display: none; }
  .card:active { cursor: grabbing; }
  .card:hover { background: #1e1e30; }
  .card.active { background: #e84393; }
  .card.active .card-label { color: rgba(0,0,0,0.6); }

  .card-thumb {
    width: 100%; aspect-ratio: 16 / 9;
    background: #2a2a3e; border-radius: 3px;
    object-fit: cover; display: block;
  }

  .card-label {
    margin-top: 7px;
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #666;
  }

  /* Text stamps */
  .text-stamps-section {
    padding: 12px;
    border-top: 1px solid #111;
    flex-shrink: 0;
  }

  .section-label {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 0.2em;
    color: #333;
    text-transform: uppercase;
    margin-bottom: 10px;
  }

  .stamps-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .stamp {
    background: #0d0d1a;
    border: 1px solid #22223a;
    border-radius: 3px;
    padding: 8px 8px;
    font-family: 'Space Mono', monospace;
    font-size: 8px;
    font-weight: 700;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: #777;
    cursor: grab;
    user-select: none;
    text-align: center;
    line-height: 1.3;
    transition: background 0.15s, border-color 0.15s, color 0.15s;
  }
  .stamp:hover { background: #18182e; border-color: #3a3a5e; color: #ccc; }
  .stamp:active { cursor: grabbing; }

  /* ── MAIN AREA ── */
  .main-area {
    flex: 1;
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
    min-width: 0;
  }

  .main-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 11px 24px;
    border-bottom: 1px solid #111;
    flex-shrink: 0;
  }

  .app-title {
    font-family: 'Orbitron', monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.22em;
    color: #333;
    text-transform: uppercase;
  }

  .publish-btn {
    font-family: 'Orbitron', monospace;
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: #0a0a0a;
    background: #e84393;
    border: none;
    padding: 9px 18px;
    cursor: pointer;
    border-radius: 2px;
    transition: background 0.15s, opacity 0.15s;
  }
  .publish-btn:hover { background: #ff55a8; }
  .publish-btn:disabled { opacity: 0.3; cursor: default; }

  /* Preview */
  .tl-preview-section {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 0;
    overflow: hidden;
    position: relative;
  }

  .tl-preview-container {
    position: relative;
    width: 100%; height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0a0a0a;
  }

  .tl-preview-container video {
    max-width: 100%; max-height: 100%;
    object-fit: contain;
    background: #0a0a0a;
  }

  #tl-text-overlay {
    position: absolute;
    bottom: 14%;
    left: 0; right: 0;
    text-align: center;
    pointer-events: none;
    font-family: 'Orbitron', monospace;
    font-size: clamp(13px, 2.2vw, 26px);
    font-weight: 900;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0 2px 16px rgba(0,0,0,1), 0 0 40px rgba(0,0,0,0.9);
    display: none;
    padding: 0 20px;
  }

  /* Controls */
  .controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 48px;
    padding: 10px 0;
    flex-shrink: 0;
  }

  .ctrl-btn {
    background: none; border: none; cursor: pointer;
    padding: 10px;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.15s;
    opacity: 0.45;
  }
  .ctrl-btn:hover { opacity: 0.8; }
  .ctrl-btn.play-pause { opacity: 0.75; }
  .ctrl-btn.play-pause:hover { opacity: 1; }
  .ctrl-btn svg { display: block; }

  /* ── TIMELINE ── */
  .timeline { position: relative; flex-shrink: 0; padding: 0 24px 14px; }

  .timeline-header {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding: 2px 0 4px;
  }

  .time-counter {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.08em;
    color: #333;
  }
  .time-counter .used { color: #e84393; }

  .ruler {
    position: relative;
    height: 28px;
    background: #0d0d0d;
    cursor: pointer;
    overflow: hidden;
  }
  .ruler canvas { display: block; width: 100%; height: 100%; }

  .timeline-body { position: relative; }
  .tracks-container { position: relative; }

  .track {
    height: 44px;
    background: #0f0f1a;
    border-top: 1px solid #1a1a2e;
    position: relative;
  }
  .track:last-child { border-bottom: 1px solid #1a1a2e; }
  .track.drag-over { background: #14142a; }
  .track.stamp-drag-over { background: #1a0f1a; }

  .track-remove {
    position: absolute;
    left: 8px; top: 50%;
    transform: translateY(-50%);
    width: 20px; height: 20px;
    background: transparent;
    border: 1px solid #1a1a2e;
    border-radius: 2px;
    color: #2a2a3e;
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 5;
    padding: 0; line-height: 1;
  }
  .track-remove:hover { color: #e84393; border-color: #e84393; }

  .clip {
    position: absolute;
    top: 4px; height: 36px;
    border-radius: 3px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: center;
    padding: 0 8px;
    font-size: 9px;
    font-family: 'Space Mono', monospace;
    text-transform: uppercase;
    letter-spacing: 0.4px;
    color: rgba(255,255,255,0.85);
    cursor: grab;
    user-select: none;
    overflow: hidden;
    white-space: nowrap;
    min-width: 16px;
    gap: 2px;
  }
  .clip.selected { outline: 2px solid #fff; outline-offset: -2px; }
  .clip.stamp-target { outline: 2px solid #e84393; outline-offset: -2px; }
  .clip:active { cursor: grabbing; }

  .clip-handle {
    position: absolute; top: 0;
    width: 6px; height: 100%;
    cursor: ew-resize; z-index: 2;
  }
  .clip-handle.left { left: 0; border-radius: 3px 0 0 3px; }
  .clip-handle.right { right: 0; border-radius: 0 3px 3px 0; }
  .clip-handle:hover, .clip-handle.dragging { background: rgba(255,255,255,0.18); }

  .clip-label {
    pointer-events: none;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
    line-height: 1;
  }

  .clip-overlay-badge {
    font-size: 7px;
    letter-spacing: 0.04em;
    color: rgba(255,255,255,0.55);
    pointer-events: none;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    line-height: 1;
    font-style: italic;
  }

  .playhead {
    position: absolute; top: 0; left: 0;
    width: 1px; height: 100%;
    background: #e84393;
    pointer-events: none; z-index: 10;
    box-shadow: 0 0 6px rgba(232,67,147,0.5);
  }

  .add-track-btn {
    height: 26px;
    background: transparent;
    border: 1px solid #1a1a2e;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    color: #2a2a3e;
    font-family: 'Space Mono', monospace;
    font-size: 16px;
    transition: color 0.15s, border-color 0.15s;
    width: 100%;
    margin-top: 2px;
  }
  .add-track-btn:hover { color: #555; border-color: #3a3a5e; }

  .drag-ghost {
    position: fixed; pointer-events: none; z-index: 1000;
    opacity: 0.75;
    padding: 5px 10px;
    background: #1e1e3a;
    border-radius: 3px;
    font-size: 9px;
    font-family: 'Space Mono', monospace;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #aaa;
  }

  .stamp-ghost {
    position: fixed; pointer-events: none; z-index: 1000;
    opacity: 0.9;
    padding: 6px 12px;
    background: rgba(232,67,147,0.12);
    border: 1px solid rgba(232,67,147,0.5);
    border-radius: 2px;
    font-family: 'Orbitron', monospace;
    font-size: 9px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #e84393;
  }

  /* ── FULLSCREEN PUBLISH ── */
  #publish-overlay {
    display: none;
    position: fixed; inset: 0;
    background: #000;
    z-index: 9998;
    align-items: center;
    justify-content: center;
  }
  #publish-overlay.active { display: flex; }

  #publish-video {
    max-width: 100%; max-height: 100%;
    object-fit: contain;
    display: none;
  }

  #publish-title-card {
    position: absolute; inset: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 18px;
    opacity: 0;
    transition: opacity 0.8s ease;
    display: none;
  }
  #publish-title-card.visible { opacity: 1; }

  .pub-card-title {
    font-family: 'Orbitron', monospace;
    font-size: clamp(22px, 5vw, 62px);
    font-weight: 900;
    letter-spacing: 0.1em;
    color: #e8e8e8;
    text-transform: uppercase;
    text-align: center;
    line-height: 1.15;
  }

  .pub-card-sub {
    font-family: 'Space Mono', monospace;
    font-size: clamp(10px, 1.2vw, 13px);
    color: #444;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }

  #publish-close {
    position: absolute; top: 22px; right: 22px;
    background: transparent;
    border: 1px solid #222;
    color: #444;
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 0.12em;
    padding: 7px 14px;
    cursor: pointer;
    text-transform: uppercase;
    transition: color 0.15s, border-color 0.15s;
  }
  #publish-close:hover { color: #888; border-color: #555; }

  #publish-text-overlay {
    position: absolute;
    bottom: 10%;
    left: 0; right: 0;
    text-align: center;
    pointer-events: none;
    font-family: 'Orbitron', monospace;
    font-size: clamp(16px, 3.5vw, 42px);
    font-weight: 900;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0 2px 24px rgba(0,0,0,1), 0 0 80px rgba(0,0,0,0.9);
    display: none;
    padding: 0 32px;
  }
</style>
</head>
<body>

<!-- ── INTRO OVERLAY ── -->
<div id="intro-overlay">
  <h1 class="intro-heading">THE TRUTH IS<br>OUT THERE</h1>
  <p class="intro-sub">You have 60 seconds. Construct your theory.</p>
  <button class="intro-btn" id="intro-begin">BEGIN</button>
</div>

<!-- ── PUBLISH OVERLAY ── -->
<div id="publish-overlay">
  <div id="publish-title-card">
    <div class="pub-card-title" id="pub-card-title">NARRATIVE<br>CONSTRUCTION KIT</div>
    <div class="pub-card-sub" id="pub-card-sub">A USER THEORY</div>
  </div>
  <video id="publish-video" playsinline></video>
  <div id="publish-text-overlay"></div>
  <button id="publish-close">✕ CLOSE</button>
</div>

<div class="layout">
  <!-- ── SIDEBAR ── -->
  <div class="sidebar">
    <div class="category-tabs" id="category-tabs">
      <button class="cat-tab active" data-cat="ALL">ALL</button>
      <button class="cat-tab" data-cat="THE AUTHORITY">THE AUTHORITY</button>
      <button class="cat-tab" data-cat="THE EVIDENCE">THE EVIDENCE</button>
      <button class="cat-tab" data-cat="THE ORDINARY">THE ORDINARY</button>
      <button class="cat-tab" data-cat="THE SIGNAL">THE SIGNAL</button>
      <button class="cat-tab" data-cat="THE REACTION">THE REACTION</button>
    </div>

    <div class="search-bar">
      <div class="search-input-wrapper">
        <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <input type="text" placeholder="SEARCH MEDIA" id="search-input">
      </div>
    </div>

    <div class="clip-preview-section">
      <div class="clip-preview-container" id="clip-preview-container">
        <span class="preview-placeholder" id="clip-placeholder">SELECT A VIDEO</span>
        <video id="clip-player" style="display:none;"></video>
      </div>
      <div class="clip-scrubber" id="clip-scrubber">
        <div class="clip-scrubber-fill" id="clip-scrubber-fill"></div>
      </div>
    </div>

    <div class="sidebar-scroll">
      <div class="media-grid" id="media-grid"></div>

      <div class="text-stamps-section">
        <div class="section-label">// TEXT</div>
        <div class="stamps-grid">
          <div class="stamp" data-stamp="COINCIDENCE?">COINCIDENCE?</div>
          <div class="stamp" data-stamp="WHAT ARE THEY HIDING?">WHAT ARE THEY HIDING?</div>
          <div class="stamp" data-stamp="EXPOSED">EXPOSED</div>
          <div class="stamp" data-stamp="FOLLOW THE MONEY">FOLLOW THE MONEY</div>
          <div class="stamp" data-stamp="THEY KNEW">THEY KNEW</div>
          <div class="stamp" data-stamp="ASK YOURSELF WHY">ASK YOURSELF WHY</div>
          <div class="stamp" data-stamp="LOOK CLOSER">LOOK CLOSER</div>
          <div class="stamp" data-stamp="WAKE UP">WAKE UP</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ── MAIN AREA ── -->
  <div class="main-area">
    <div class="main-header">
      <div class="app-title">Narrative Construction Kit</div>
      <button class="publish-btn" id="publish-btn">PUBLISH YOUR THEORY</button>
    </div>

    <div class="tl-preview-section">
      <div class="tl-preview-container" id="tl-preview-container">
        <span class="preview-placeholder" id="tl-placeholder">TIMELINE PREVIEW</span>
        <video id="timeline-player" style="display:none;"></video>
        <div id="tl-text-overlay"></div>
      </div>
    </div>

    <div class="controls">
      <button class="ctrl-btn" id="btn-back">
        <svg width="26" height="26" viewBox="0 0 28 28" fill="none">
          <polygon points="14,6 4,14 14,22" fill="#ccc"/>
          <polygon points="24,6 14,14 24,22" fill="#ccc"/>
        </svg>
      </button>
      <button class="ctrl-btn play-pause" id="btn-play">
        <svg width="34" height="34" viewBox="0 0 36 36" fill="none" id="play-icon">
          <polygon points="8,4 8,32 30,18" fill="#ccc"/>
        </svg>
      </button>
      <button class="ctrl-btn" id="btn-fwd">
        <svg width="26" height="26" viewBox="0 0 28 28" fill="none">
          <polygon points="14,6 24,14 14,22" fill="#ccc"/>
          <polygon points="4,6 14,14 4,22" fill="#ccc"/>
        </svg>
      </button>
    </div>

    <div class="timeline" id="timeline">
      <div class="timeline-header">
        <div class="time-counter" id="time-counter"><span class="used">0</span>/60s</div>
      </div>
      <div class="timeline-body">
        <div class="playhead" id="playhead"></div>
        <div class="ruler" id="ruler">
          <canvas id="ruler-canvas"></canvas>
        </div>
        <div class="tracks-container" id="tracks-container"></div>
      </div>
      <button class="add-track-btn" id="add-track-btn">+</button>
    </div>
  </div>
</div>

<script>
  // ── Constants ──
  const MAX_DURATION = 60;

  // ── Refs ──
  const clipPlayer    = document.getElementById('clip-player');
  const clipPlaceholder = document.getElementById('clip-placeholder');
  const clipPreviewContainer = document.getElementById('clip-preview-container');
  const clipScrubber  = document.getElementById('clip-scrubber');
  const clipScrubberFill = document.getElementById('clip-scrubber-fill');
  const tlPlayer      = document.getElementById('timeline-player');
  const tlPlaceholder = document.getElementById('tl-placeholder');
  const tlTextOverlay = document.getElementById('tl-text-overlay');
  const searchInput   = document.getElementById('search-input');
  const mediaGrid     = document.getElementById('media-grid');
  const btnPlay       = document.getElementById('btn-play');
  const playIcon      = document.getElementById('play-icon');
  const btnBack       = document.getElementById('btn-back');
  const btnFwd        = document.getElementById('btn-fwd');
  const ruler         = document.getElementById('ruler');
  const rulerCanvas   = document.getElementById('ruler-canvas');
  const playhead      = document.getElementById('playhead');
  const tracksContainer = document.getElementById('tracks-container');
  const addTrackBtn   = document.getElementById('add-track-btn');
  const timeCounter   = document.getElementById('time-counter');
  const ctx           = rulerCanvas.getContext('2d');

  const getAllTracks = () => document.querySelectorAll('.track');

  let trackCount = 0;
  const CLIP_COLORS = [
    '#6c5ce7','#e84393','#00b894','#fdcb6e','#e17055',
    '#0984e3','#00cec9','#d63031','#a29bfe','#55efc4'
  ];
  let colorIndex = 0;

  let timelineClips        = [];
  let isTimelinePlaying    = false;
  let timelinePlayTime     = 0;
  let lastFrameTime        = 0;
  let activeClipForPlayback = null;
  let pendingSeekClip      = null;
  let tlCurrentSrc         = '';
  let selectedClipIds      = new Set();
  let assetMeta            = {};
  let activeCategory       = 'ALL';

  // ── Undo ──
  const undoStack = [];
  function pushUndo() {
    undoStack.push(JSON.stringify(timelineClips));
    if (undoStack.length > 50) undoStack.shift();
  }
  function undo() {
    if (!undoStack.length) return;
    timelineClips = JSON.parse(undoStack.pop());
    selectedClipIds.clear();
    renderClips();
    updateTimeCounter();
    syncTimelinePreview();
  }

  // ── Intro ──
  document.getElementById('intro-begin').addEventListener('click', () => {
    const o = document.getElementById('intro-overlay');
    o.classList.add('dismissing');
    o.addEventListener('animationend', () => o.remove(), { once: true });
  });

  // ── Category tabs ──
  document.querySelectorAll('.cat-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.cat-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      activeCategory = tab.dataset.cat;
      filterGrid();
    });
  });

  function filterGrid() {
    const query = searchInput.value.trim().toLowerCase();
    document.querySelectorAll('#media-grid .card').forEach(card => {
      const label   = (card.dataset.label || '').toLowerCase();
      const cardCat = card.dataset.category || 'ALL';
      const catOk   = activeCategory === 'ALL' || cardCat === activeCategory;
      const srchOk  = !query || label.includes(query);
      card.classList.toggle('hidden', !catOk || !srchOk);
    });
  }

  searchInput.addEventListener('input', filterGrid);
  searchInput.addEventListener('keydown', e => e.stopPropagation());

  // ── Time counter ──
  function updateTimeCounter() {
    let maxEnd = 0;
    timelineClips.forEach(c => { maxEnd = Math.max(maxEnd, c.start + c.duration); });
    const used = Math.min(Math.round(maxEnd), MAX_DURATION);
    timeCounter.innerHTML = `<span class="used">${used}</span>/${MAX_DURATION}s`;
  }

  // ── Track management ──
  function createTrack() {
    const idx = trackCount++;
    const track = document.createElement('div');
    track.className = 'track';
    track.dataset.track = idx;
    const btn = document.createElement('button');
    btn.className = 'track-remove';
    btn.innerHTML = '&minus;';
    btn.addEventListener('click', e => { e.stopPropagation(); removeTrack(idx); });
    track.appendChild(btn);
    tracksContainer.appendChild(track);
    updateTrackButtons();
    return track;
  }

  function removeTrack(idx) {
    if (getAllTracks().length <= 1) return;
    if (timelineClips.some(c => c.track === idx)) return;
    const el = document.querySelector(`.track[data-track="${idx}"]`);
    if (el) el.remove();
    updateTrackButtons();
  }

  function updateTrackButtons() {
    const tracks = getAllTracks();
    tracks.forEach(track => {
      const idx     = parseInt(track.dataset.track);
      const hasClip = timelineClips.some(c => c.track === idx);
      const btn     = track.querySelector('.track-remove');
      if (btn) btn.style.display = (!hasClip && tracks.length > 1) ? 'flex' : 'none';
    });
  }

  createTrack(); createTrack(); createTrack();
  addTrackBtn.addEventListener('click', createTrack);

  // ── Clip preview scrub ──
  clipPreviewContainer.addEventListener('mousedown', e => {
    if (!clipPlayer.duration) return;
    e.preventDefault();
    const startX = e.clientX;
    let scrubbing = false;
    function onMove(e2) {
      if (!scrubbing && Math.abs(e2.clientX - startX) > 3) { scrubbing = true; clipPlayer.pause(); }
      if (scrubbing) {
        const rect = clipPreviewContainer.getBoundingClientRect();
        const pct  = Math.max(0, Math.min(1, (e2.clientX - rect.left) / rect.width));
        clipPlayer.currentTime = pct * clipPlayer.duration;
        clipScrubberFill.style.width = pct * 100 + '%';
      }
    }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      if (!scrubbing) clipPlayer.paused ? clipPlayer.play() : clipPlayer.pause();
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  clipScrubber.addEventListener('mousedown', e => {
    const seek = e2 => {
      if (!clipPlayer.duration) return;
      const rect = clipScrubber.getBoundingClientRect();
      const pct  = Math.max(0, Math.min(1, (e2.clientX - rect.left) / rect.width));
      clipPlayer.currentTime = pct * clipPlayer.duration;
      clipScrubberFill.style.width = pct * 100 + '%';
    };
    seek(e);
    const up = () => { document.removeEventListener('mousemove', seek); document.removeEventListener('mouseup', up); };
    document.addEventListener('mousemove', seek);
    document.addEventListener('mouseup', up);
  });

  clipPlayer.addEventListener('timeupdate', () => {
    if (clipPlayer.duration) clipScrubberFill.style.width = clipPlayer.currentTime / clipPlayer.duration * 100 + '%';
  });
  clipPlayer.addEventListener('ended', () => { clipScrubberFill.style.width = '100%'; });

  // ── Thumbnail generation ──
  function generateThumbnail(card) {
    const video = document.createElement('video');
    video.preload = 'metadata'; video.muted = true;
    video.src = card.dataset.src;
    video.addEventListener('loadedmetadata', () => {
      video.currentTime = video.duration * (0.2 + Math.random() * 0.3);
      card.dataset.duration = video.duration;
    });
    video.addEventListener('seeked', () => {
      const canvas = card.querySelector('.card-thumb');
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
      video.src = ''; video.load();
    });
  }

  // ── Card setup ──
  function setupCardClick(card) {
    card.addEventListener('click', () => {
      document.querySelectorAll('#media-grid .card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      clipPlaceholder.style.display = 'none';
      clipPlayer.style.display = 'block';
      clipPlayer.src = card.dataset.src;
      clipPlayer.play();
      clipScrubberFill.style.width = '0%';
    });
  }

  function setupCardDrag(card) {
    card.addEventListener('mousedown', e => {
      if (e.button !== 0) return;
      const startX = e.clientX, startY = e.clientY;
      let dragging = false, ghost = null, dragData = null;

      function onMove(e2) {
        const dx = e2.clientX - startX, dy = e2.clientY - startY;
        if (!dragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
          dragging = true;
          dragData = { src: card.dataset.src, label: card.dataset.label, duration: parseFloat(card.dataset.duration) || 30 };
          ghost = document.createElement('div');
          ghost.className = 'drag-ghost';
          ghost.textContent = dragData.label;
          document.body.appendChild(ghost);
        }
        if (dragging && ghost) {
          ghost.style.left = e2.clientX + 12 + 'px';
          ghost.style.top  = e2.clientY - 16 + 'px';
          getAllTracks().forEach(t => t.classList.remove('drag-over'));
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          if (el && el.closest('.track')) el.closest('.track').classList.add('drag-over');
        }
      }

      function onUp(e2) {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        if (ghost) { ghost.remove(); ghost = null; }
        getAllTracks().forEach(t => t.classList.remove('drag-over'));
        if (dragging && dragData) {
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          const track = el && el.closest('.track');
          if (track) {
            const trackIdx = parseInt(track.dataset.track);
            const rect     = track.getBoundingClientRect();
            const dropPct  = (e2.clientX - rect.left) / rect.width;
            const dropTime = Math.max(0, Math.min(dropPct * MAX_DURATION, MAX_DURATION - 0.5));
            const clipDur  = Math.min(dragData.duration, MAX_DURATION - dropTime);
            if (clipDur > 0.5) addClip(trackIdx, dropTime, clipDur, dragData.src, dragData.label, dragData.duration);
          }
        }
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // ── Text stamp drag ──
  function setupStampDrag(stampEl) {
    stampEl.addEventListener('mousedown', e => {
      if (e.button !== 0) return;
      const startX = e.clientX, startY = e.clientY;
      const stampText = stampEl.dataset.stamp;
      let dragging = false, ghost = null;

      function onMove(e2) {
        const dx = e2.clientX - startX, dy = e2.clientY - startY;
        if (!dragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
          dragging = true;
          ghost = document.createElement('div');
          ghost.className = 'stamp-ghost';
          ghost.textContent = stampText;
          document.body.appendChild(ghost);
        }
        if (dragging && ghost) {
          ghost.style.left = e2.clientX + 12 + 'px';
          ghost.style.top  = e2.clientY - 16 + 'px';
          document.querySelectorAll('.clip').forEach(c => c.classList.remove('stamp-target'));
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          const clipEl = el && el.closest('.clip');
          if (clipEl) clipEl.classList.add('stamp-target');
        }
      }

      function onUp(e2) {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        if (ghost) { ghost.remove(); ghost = null; }
        document.querySelectorAll('.clip').forEach(c => c.classList.remove('stamp-target'));
        if (dragging) {
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          const clipEl = el && el.closest('.clip');
          if (clipEl) {
            const clipId = parseFloat(clipEl.dataset.clipId);
            const clip   = timelineClips.find(c => c.id === clipId);
            if (clip) {
              pushUndo();
              clip.textOverlay = stampText;
              renderClips();
              syncTimelinePreview();
            }
          }
        }
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // ── Media library ──
  const FALLBACK_FILES = [
    '40k end up in morgues.mp4','a_bomb.mp4','come stay in this hotel.mp4',
    'enemy would like.mp4','lesbian implications.mp4','psychiatrists believe.mp4',
    'sign of a poorly-balanced economy.mp4','through the mouth and nose.mp4',
    'traffic signs.mp4','where does pollution come from.mp4'
  ];

  async function loadMetadata() {
    try {
      const r = await fetch('Assets/metadata.json');
      return r.ok ? await r.json() : {};
    } catch { return {}; }
  }

  async function scanAssetsDirectory() {
    try {
      const r = await fetch('Assets/');
      if (!r.ok) return [];
      const html = await r.text();
      const doc  = new DOMParser().parseFromString(html, 'text/html');
      const files = [];
      doc.querySelectorAll('a').forEach(link => {
        const href = link.getAttribute('href');
        if (href && /\.mp4$/i.test(href)) {
          const raw     = href.split('/').pop();
          const decoded = decodeURIComponent(raw);
          const label   = decoded.replace(/\.mp4$/i,'').replace(/[_-]/g,' ').toUpperCase();
          files.push({ src: 'Assets/' + raw, label, filename: decoded });
        }
      });
      return files;
    } catch { return []; }
  }

  function buildFileList(filenames) {
    return filenames.map(f => ({
      src: 'Assets/' + encodeURIComponent(f),
      label: f.replace(/\.mp4$/i,'').replace(/[_-]/g,' ').toUpperCase(),
      filename: f
    }));
  }

  function addCardToGrid(f) {
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.src      = f.src;
    card.dataset.label    = f.label;
    card.dataset.category = assetMeta[f.filename] || 'ALL';

    const canvas = document.createElement('canvas');
    canvas.className = 'card-thumb';
    card.appendChild(canvas);

    const lbl = document.createElement('div');
    lbl.className = 'card-label';
    lbl.textContent = f.label;
    card.appendChild(lbl);

    mediaGrid.appendChild(card);
    generateThumbnail(card);
    setupCardClick(card);
    setupCardDrag(card);
  }

  async function loadMediaLibrary() {
    assetMeta = await loadMetadata();
    let files = await scanAssetsDirectory();
    if (!files.length) files = buildFileList(FALLBACK_FILES);
    files.sort((a, b) => a.label.localeCompare(b.label));
    files.forEach(addCardToGrid);
  }

  document.querySelectorAll('.stamp').forEach(setupStampDrag);

  // ── Clip management ──
  function addClip(trackIdx, startTime, clipDur, src, label, srcDuration) {
    pushUndo();
    const start    = Math.max(0, Math.min(startTime, MAX_DURATION - 0.5));
    const duration = Math.min(clipDur, MAX_DURATION - start);
    if (duration < 0.5) return;
    timelineClips.push({
      id: Date.now() + Math.random(),
      track: trackIdx,
      start, duration, src, label,
      srcDuration, srcOffset: 0,
      color: CLIP_COLORS[colorIndex++ % CLIP_COLORS.length],
      textOverlay: null
    });
    renderClips();
    drawRuler();
    syncTimelinePreview();
    updateTimeCounter();
  }

  function renderClips() {
    document.querySelectorAll('.clip').forEach(el => el.remove());
    timelineClips.forEach(clip => {
      const track = document.querySelector(`.track[data-track="${clip.track}"]`);
      if (!track) return;

      const el = document.createElement('div');
      el.className = 'clip' + (selectedClipIds.has(clip.id) ? ' selected' : '');
      el.dataset.clipId = clip.id;
      el.style.background = clip.color;
      el.style.left  = (clip.start    / MAX_DURATION * 100) + '%';
      el.style.width = (clip.duration / MAX_DURATION * 100) + '%';

      const handleL = document.createElement('div'); handleL.className = 'clip-handle left';
      const handleR = document.createElement('div'); handleR.className = 'clip-handle right';
      const labelEl = document.createElement('span'); labelEl.className = 'clip-label'; labelEl.textContent = clip.label;

      el.appendChild(handleL);
      el.appendChild(labelEl);

      if (clip.textOverlay) {
        const badge = document.createElement('span');
        badge.className = 'clip-overlay-badge';
        badge.textContent = '↳ ' + clip.textOverlay;
        el.appendChild(badge);
      }

      el.appendChild(handleR);
      track.appendChild(el);

      el.addEventListener('click', e => {
        e.stopPropagation();
        if (e.shiftKey || e.metaKey || e.ctrlKey) {
          selectedClipIds.has(clip.id) ? selectedClipIds.delete(clip.id) : selectedClipIds.add(clip.id);
        } else {
          if (selectedClipIds.has(clip.id) && selectedClipIds.size === 1) selectedClipIds.clear();
          else { selectedClipIds.clear(); selectedClipIds.add(clip.id); }
        }
        renderClips();
      });

      setupClipDrag(el, clip);
      setupClipResize(handleL, clip, 'left');
      setupClipResize(handleR, clip, 'right');
    });
    updateTrackButtons();
  }

  function setupClipDrag(el, clip) {
    el.addEventListener('mousedown', e => {
      if (e.target.classList.contains('clip-handle')) return;
      e.stopPropagation(); e.preventDefault();
      const startX   = e.clientX;
      const origStart = clip.start;
      let pushed = false;

      function onMove(e2) {
        if (!pushed) { pushUndo(); pushed = true; }
        const rulerRect = ruler.getBoundingClientRect();
        const dtSec    = ((e2.clientX - startX) / rulerRect.width) * MAX_DURATION;
        clip.start     = Math.max(0, Math.min(MAX_DURATION - clip.duration, origStart + dtSec));
        const trackEl  = document.elementFromPoint(e2.clientX, e2.clientY);
        const newTrack = trackEl && trackEl.closest('.track');
        if (newTrack) clip.track = parseInt(newTrack.dataset.track);
        renderClips();
        updateTimeCounter();
      }

      function onUp() { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  function setupClipResize(handle, clip, side) {
    handle.addEventListener('mousedown', e => {
      e.stopPropagation(); e.preventDefault();
      pushUndo();
      const startX    = e.clientX;
      const origStart  = clip.start;
      const origDur    = clip.duration;
      const origOffset = clip.srcOffset;
      handle.classList.add('dragging');

      function onMove(e2) {
        const rulerRect = ruler.getBoundingClientRect();
        const dtSec     = ((e2.clientX - startX) / rulerRect.width) * MAX_DURATION;
        if (side === 'left') {
          const newStart = Math.max(0, origStart + dtSec);
          const delta    = newStart - origStart;
          const newDur   = origDur - delta;
          if (newDur > 0.5) { clip.start = newStart; clip.duration = newDur; clip.srcOffset = Math.max(0, origOffset + delta); }
        } else {
          const maxDur   = Math.min(clip.srcDuration - clip.srcOffset, MAX_DURATION - clip.start);
          clip.duration  = Math.max(0.5, Math.min(origDur + dtSec, maxDur));
        }
        renderClips();
        updateTimeCounter();
      }

      function onUp() { handle.classList.remove('dragging'); document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // ── Timeline preview sync ──
  function syncTimelinePreview() {
    const clip = getClipAtTime(timelinePlayTime);
    if (clip) {
      tlPlaceholder.style.display = 'none';
      tlPlayer.style.display = 'block';
      const targetTime = clip.srcOffset + (timelinePlayTime - clip.start);
      if (tlCurrentSrc === clip.src) {
        tlPlayer.currentTime = targetTime;
        if (isTimelinePlaying && tlPlayer.paused) tlPlayer.play();
        activeClipForPlayback = clip;
      } else {
        tlPlayer.pause();
        pendingSeekClip = clip;
        tlCurrentSrc = clip.src;
        tlPlayer.src = clip.src;
        tlPlayer.load();
        activeClipForPlayback = clip;
      }
      if (clip.textOverlay) { tlTextOverlay.textContent = clip.textOverlay; tlTextOverlay.style.display = 'block'; }
      else { tlTextOverlay.style.display = 'none'; }
    } else {
      tlPlayer.pause();
      activeClipForPlayback = null;
      tlTextOverlay.style.display = 'none';
    }
  }

  tlPlayer.addEventListener('loadeddata', () => {
    if (pendingSeekClip) {
      const clip = pendingSeekClip; pendingSeekClip = null;
      tlPlayer.currentTime = Math.max(0, clip.srcOffset + (timelinePlayTime - clip.start));
      if (isTimelinePlaying) tlPlayer.play();
    }
  });

  function setPlayIcon(showPlay) {
    playIcon.innerHTML = showPlay
      ? '<polygon points="8,4 8,32 30,18" fill="#ccc"/>'
      : '<rect x="7" y="5" width="7" height="26" rx="1" fill="#ccc"/><rect x="22" y="5" width="7" height="26" rx="1" fill="#ccc"/>';
  }

  btnPlay.addEventListener('click', toggleTimelinePlayback);
  btnBack.addEventListener('click', () => { timelinePlayTime = Math.max(0, timelinePlayTime - 5); updatePlayhead(); syncTimelinePreview(); });
  btnFwd.addEventListener('click',  () => { timelinePlayTime = Math.min(MAX_DURATION, timelinePlayTime + 5); updatePlayhead(); syncTimelinePreview(); });

  function toggleTimelinePlayback() {
    isTimelinePlaying ? stopTimelinePlayback() : startTimelinePlayback();
  }
  function startTimelinePlayback() {
    if (!timelineClips.length) return;
    isTimelinePlaying = true;
    setPlayIcon(false);
    lastFrameTime = performance.now();
    syncTimelinePreview();
    requestAnimationFrame(timelineTick);
  }
  function stopTimelinePlayback() {
    isTimelinePlaying = false;
    setPlayIcon(true);
    tlPlayer.pause();
    activeClipForPlayback = null;
  }

  function getClipAtTime(t) {
    let best = null;
    for (const clip of timelineClips) {
      if (t >= clip.start && t < clip.start + clip.duration) {
        if (!best || clip.track < best.track) best = clip;
      }
    }
    return best;
  }

  function timelineTick(now) {
    if (!isTimelinePlaying) return;
    const dt = (now - lastFrameTime) / 1000;
    lastFrameTime = now;
    timelinePlayTime += dt;
    if (timelinePlayTime >= MAX_DURATION) {
      timelinePlayTime = 0;
      stopTimelinePlayback();
      updatePlayhead();
      return;
    }
    updatePlayhead();
    const clip = getClipAtTime(timelinePlayTime);
    if (clip !== activeClipForPlayback) syncTimelinePreview();
    requestAnimationFrame(timelineTick);
  }

  // ── Ruler ──
  function drawRuler() {
    const dpr  = window.devicePixelRatio || 1;
    const rect = rulerCanvas.getBoundingClientRect();
    rulerCanvas.width  = rect.width  * dpr;
    rulerCanvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, rect.width, rect.height);

    const interval   = getTickInterval(MAX_DURATION, rect.width);
    const totalTicks = Math.floor(MAX_DURATION / interval);

    for (let i = 0; i <= totalTicks; i++) {
      const time    = i * interval;
      const x       = (time / MAX_DURATION) * rect.width;
      const isMajor = (i % 5 === 0);
      ctx.beginPath();
      ctx.moveTo(x, isMajor ? 4 : 14);
      ctx.lineTo(x, rect.height);
      ctx.strokeStyle = isMajor ? '#2a2a2a' : '#1a1a1a';
      ctx.lineWidth = 1; ctx.stroke();
      if (isMajor) {
        ctx.fillStyle = '#444';
        ctx.font = '9px "Space Mono", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(formatTime(time), x + 3, 12);
      }
    }

    // 60s limit marker
    ctx.beginPath();
    ctx.moveTo(rect.width - 1, 0);
    ctx.lineTo(rect.width - 1, rect.height);
    ctx.strokeStyle = 'rgba(232,67,147,0.7)';
    ctx.lineWidth = 2; ctx.stroke();
    ctx.fillStyle = 'rgba(232,67,147,0.85)';
    ctx.font = 'bold 9px "Space Mono", monospace';
    ctx.textAlign = 'right';
    ctx.fillText('60s', rect.width - 4, 12);
    ctx.textAlign = 'left';
  }

  function getTickInterval(duration, width) {
    const raw   = duration / (width / 40);
    const steps = [1, 2, 5, 10, 15, 30, 60];
    for (const s of steps) if (s >= raw) return s;
    return 60;
  }

  function formatTime(s) {
    return Math.floor(s / 60) + ':' + String(Math.floor(s % 60)).padStart(2, '0');
  }

  function updatePlayhead() {
    playhead.style.left = (timelinePlayTime / MAX_DURATION * 100) + '%';
  }

  ruler.addEventListener('mousedown', e => {
    const seek = e2 => {
      const rect = ruler.getBoundingClientRect();
      timelinePlayTime = Math.max(0, Math.min(1, (e2.clientX - rect.left) / rect.width)) * MAX_DURATION;
      updatePlayhead(); syncTimelinePreview();
    };
    seek(e);
    const up = () => { document.removeEventListener('mousemove', seek); document.removeEventListener('mouseup', up); };
    document.addEventListener('mousemove', seek);
    document.addEventListener('mouseup', up);
  });

  tracksContainer.addEventListener('click', () => {
    if (selectedClipIds.size) { selectedClipIds.clear(); renderClips(); }
  });

  // ── Keyboard ──
  document.addEventListener('keydown', e => {
    if (document.getElementById('intro-overlay')) return;
    if (e.code === 'Space') { e.preventDefault(); btnPlay.click(); }
    if ((e.code === 'Backspace' || e.code === 'Delete') && selectedClipIds.size) {
      e.preventDefault();
      pushUndo();
      timelineClips = timelineClips.filter(c => !selectedClipIds.has(c.id));
      selectedClipIds.clear();
      renderClips(); drawRuler(); syncTimelinePreview(); updateTimeCounter();
    }
    if (e.code === 'KeyZ' && (e.metaKey || e.ctrlKey) && !e.shiftKey) { e.preventDefault(); undo(); }
    if (e.code === 'Escape') {
      const po = document.getElementById('publish-overlay');
      if (po.classList.contains('active')) endPublish();
    }
  });

  // ── PUBLISH ──
  const publishOverlay   = document.getElementById('publish-overlay');
  const publishVideo     = document.getElementById('publish-video');
  const publishTitleCard = document.getElementById('publish-title-card');
  const pubCardTitle     = document.getElementById('pub-card-title');
  const pubCardSub       = document.getElementById('pub-card-sub');
  const publishTextOvr   = document.getElementById('publish-text-overlay');

  let publishClips = [], publishIdx = 0, publishActive = false, publishTimer = null;

  document.getElementById('publish-btn').addEventListener('click', () => {
    if (!timelineClips.length) return;
    publishClips = [...timelineClips].sort((a, b) => a.start - b.start);
    publishIdx   = 0;
    publishActive = true;

    publishOverlay.classList.add('active');
    publishVideo.style.display   = 'none';
    publishTextOvr.style.display = 'none';

    // Show open title card
    showTitleCard('NARRATIVE<br>CONSTRUCTION KIT', 'A USER THEORY', () => {
      if (publishActive) playPublishClip();
    });
  });

  function showTitleCard(title, sub, afterMs, callback) {
    if (typeof afterMs === 'function') { callback = afterMs; afterMs = 3000; }
    pubCardTitle.innerHTML = title;
    pubCardSub.textContent  = sub;
    publishTitleCard.style.display = 'flex';
    publishVideo.style.display     = 'none';
    publishTextOvr.style.display   = 'none';
    requestAnimationFrame(() => {
      requestAnimationFrame(() => { publishTitleCard.classList.add('visible'); });
    });
    publishTimer = setTimeout(() => {
      publishTitleCard.classList.remove('visible');
      setTimeout(() => {
        publishTitleCard.style.display = 'none';
        if (callback && publishActive) callback();
      }, 850);
    }, afterMs);
  }

  function playPublishClip() {
    if (!publishActive) return;
    if (publishIdx >= publishClips.length) {
      showTitleCard('THE TRUTH IS<br>OUT THERE', 'THEORY COMPLETE', 4000);
      return;
    }
    const clip = publishClips[publishIdx];
    publishVideo.style.display = 'block';
    publishVideo.src = clip.src;
    publishVideo.currentTime = clip.srcOffset || 0;

    if (clip.textOverlay) { publishTextOvr.textContent = clip.textOverlay; publishTextOvr.style.display = 'block'; }
    else { publishTextOvr.style.display = 'none'; }

    publishVideo.play();
    publishTimer = setTimeout(() => {
      publishVideo.pause();
      publishIdx++;
      playPublishClip();
    }, clip.duration * 1000);
  }

  function endPublish() {
    publishActive = false;
    clearTimeout(publishTimer);
    publishVideo.pause();
    publishVideo.src = '';
    publishTitleCard.classList.remove('visible');
    publishTitleCard.style.display = 'none';
    publishTextOvr.style.display   = 'none';
    publishOverlay.classList.remove('active');
    publishIdx = 0;
  }

  document.getElementById('publish-close').addEventListener('click', endPublish);

  // ── Init ──
  updatePlayhead();
  updateTimeCounter();
  loadMediaLibrary();

  document.fonts.ready.then(() => { drawRuler(); });
  window.addEventListener('resize', () => { drawRuler(); renderClips(); });
</script>
</body>
</html>
