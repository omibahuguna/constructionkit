<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Video Curation Tool</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
    overflow: hidden;
    background: #0a0a0a;
    font-family: 'IBM Plex Mono', monospace;
    color: #ccc;
  }

  .layout {
    display: flex;
    height: 100vh;
  }

  /* ── Sidebar ── */
  .sidebar {
    width: 40%;
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
  }

  .search-bar {
    padding: 12px 16px;
  }

  .search-input-wrapper {
    display: flex;
    align-items: center;
    background: #0a0a0a;
    border-radius: 4px;
    padding: 10px 12px;
    gap: 10px;
  }

  .search-icon {
    flex-shrink: 0;
    width: 16px;
    height: 16px;
    opacity: 0.5;
  }

  .search-input-wrapper input {
    background: none;
    border: none;
    outline: none;
    color: #ccc;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
    width: 100%;
  }

  .search-input-wrapper input::placeholder {
    color: #555;
  }

  .clip-preview-section {
    flex-shrink: 0;
  }

  .clip-preview-container {
    background: #0a0a0a;
    display: flex;
    align-items: center;
    justify-content: center;
    aspect-ratio: 16 / 9;
    position: relative;
    cursor: pointer;
  }

  .clip-preview-container video {
    width: 100%;
    height: 100%;
    display: block;
    object-fit: contain;
    background: #0a0a0a;
  }

  .preview-placeholder {
    color: #333;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
    position: absolute;
    pointer-events: none;
  }

  .clip-scrubber {
    height: 4px;
    background: #111;
    cursor: pointer;
    position: relative;
  }

  .clip-scrubber-fill {
    height: 100%;
    background: #e84393;
    width: 0%;
    pointer-events: none;
  }

  .media-grid {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    align-content: start;
  }

  .media-grid::-webkit-scrollbar {
    width: 6px;
  }

  .media-grid::-webkit-scrollbar-track {
    background: transparent;
  }

  .media-grid::-webkit-scrollbar-thumb {
    background: #2a2a3e;
    border-radius: 3px;
  }

  .card {
    background: #12121e;
    border-radius: 6px;
    padding: 10px;
    cursor: grab;
    transition: background 0.15s;
    user-select: none;
  }

  .card.hidden {
    display: none;
  }

  .card:active {
    cursor: grabbing;
  }

  .card:hover {
    background: #1e1e30;
  }

  .card.active {
    background: #e84393;
  }

  .card.active .card-label {
    color: #2d1b4e;
  }

  .card-thumb {
    width: 100%;
    aspect-ratio: 16 / 9;
    background: #2a2a3e;
    border-radius: 4px;
    object-fit: cover;
    display: block;
  }

  .card-label {
    margin-top: 8px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #888;
  }

  /* ── Main Area ── */
  .main-area {
    flex: 1;
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
  }

  .tl-preview-section {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 0;
    overflow: hidden;
  }

  .tl-preview-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0a0a0a;
  }

  .tl-preview-container video {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    background: #0a0a0a;
  }

  .controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 48px;
    padding: 16px 0;
    flex-shrink: 0;
  }

  .ctrl-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.15s;
    opacity: 0.5;
  }

  .ctrl-btn:hover {
    opacity: 0.85;
  }

  .ctrl-btn.play-pause {
    opacity: 0.8;
  }

  .ctrl-btn.play-pause:hover {
    opacity: 1;
  }

  .ctrl-btn svg {
    display: block;
  }

  /* ── Timeline ── */
  .timeline {
    position: relative;
    flex-shrink: 0;
    padding: 0 24px 16px;
  }

  .ruler {
    position: relative;
    height: 28px;
    background: #111;
    cursor: pointer;
    overflow: hidden;
  }

  .ruler canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .timeline-body {
    position: relative;
  }

  .tracks-container {
    position: relative;
  }

  .track {
    height: 44px;
    background: #0f0f1a;
    border-top: 1px solid #1a1a2e;
    position: relative;
  }

  .track:last-child {
    border-bottom: 1px solid #1a1a2e;
  }

  .track.drag-over {
    background: #14142a;
  }

  .track-remove {
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background: transparent;
    border: 1px solid #2a2a3e;
    border-radius: 3px;
    color: #333;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 14px;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 5;
    padding: 0;
    line-height: 1;
  }

  .track-remove:hover {
    color: #e84393;
    border-color: #e84393;
  }

  .clip {
    position: absolute;
    top: 4px;
    height: 36px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    padding: 0 8px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: rgba(255,255,255,0.8);
    cursor: grab;
    user-select: none;
    overflow: hidden;
    white-space: nowrap;
    min-width: 20px;
  }

  .clip.selected {
    outline: 2px solid #fff;
    outline-offset: -2px;
  }

  .clip:active {
    cursor: grabbing;
  }

  .clip-handle {
    position: absolute;
    top: 0;
    width: 6px;
    height: 100%;
    cursor: ew-resize;
    z-index: 2;
  }

  .clip-handle.left {
    left: 0;
    border-radius: 4px 0 0 4px;
  }

  .clip-handle.right {
    right: 0;
    border-radius: 0 4px 4px 0;
  }

  .clip-handle:hover,
  .clip-handle.dragging {
    background: rgba(255,255,255,0.15);
  }

  .clip-label {
    pointer-events: none;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .playhead {
    position: absolute;
    top: 0;
    left: 0;
    width: 1px;
    height: 100%;
    background: #e84393;
    pointer-events: none;
    z-index: 10;
    box-shadow: 0 0 4px rgba(232, 67, 147, 0.4);
  }

  .add-track-btn {
    height: 32px;
    background: transparent;
    border: 1px solid #2a2a3e;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #333;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 16px;
    transition: color 0.15s, border-color 0.15s;
    width: 100%;
  }

  .add-track-btn:hover {
    color: #666;
    border-color: #4a4a6e;
  }

  .drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.7;
    padding: 6px 12px;
    background: #2a2a5e;
    border-radius: 4px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #ccc;
    font-family: 'IBM Plex Mono', monospace;
  }
</style>
</head>
<body>
<div class="layout">
  <div class="sidebar">
    <div class="search-bar">
      <div class="search-input-wrapper">
        <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"/>
          <line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <input type="text" placeholder="SEARCH MEDIA" id="search-input">
      </div>
    </div>
    <div class="clip-preview-section">
      <div class="clip-preview-container" id="clip-preview-container">
        <span class="preview-placeholder" id="clip-placeholder">SELECT A VIDEO</span>
        <video id="clip-player" style="display:none;"></video>
      </div>
      <div class="clip-scrubber" id="clip-scrubber">
        <div class="clip-scrubber-fill" id="clip-scrubber-fill"></div>
      </div>
    </div>
    <div class="media-grid" id="media-grid"></div>
  </div>
  <div class="main-area">
    <div class="tl-preview-section">
      <div class="tl-preview-container" id="tl-preview-container">
        <span class="preview-placeholder" id="tl-placeholder">TIMELINE PREVIEW</span>
        <video id="timeline-player" style="display:none;"></video>
      </div>
    </div>
    <div class="controls">
      <button class="ctrl-btn" id="btn-back">
        <svg width="28" height="28" viewBox="0 0 28 28" fill="none">
          <polygon points="14,6 4,14 14,22" fill="#ccc"/>
          <polygon points="24,6 14,14 24,22" fill="#ccc"/>
        </svg>
      </button>
      <button class="ctrl-btn play-pause" id="btn-play">
        <svg width="36" height="36" viewBox="0 0 36 36" fill="none" id="play-icon">
          <polygon points="8,4 8,32 30,18" fill="#ccc"/>
        </svg>
      </button>
      <button class="ctrl-btn" id="btn-fwd">
        <svg width="28" height="28" viewBox="0 0 28 28" fill="none">
          <polygon points="14,6 24,14 14,22" fill="#ccc"/>
          <polygon points="4,6 14,14 4,22" fill="#ccc"/>
        </svg>
      </button>
    </div>
    <div class="timeline" id="timeline">
      <div class="timeline-body">
        <div class="playhead" id="playhead"></div>
        <div class="ruler" id="ruler">
          <canvas id="ruler-canvas"></canvas>
        </div>
        <div class="tracks-container" id="tracks-container"></div>
      </div>
      <button class="add-track-btn" id="add-track-btn">+</button>
    </div>
  </div>
</div>

<script>
  // ── Element references ──
  const clipPlayer = document.getElementById('clip-player');
  const clipPlaceholder = document.getElementById('clip-placeholder');
  const clipPreviewContainer = document.getElementById('clip-preview-container');
  const clipScrubber = document.getElementById('clip-scrubber');
  const clipScrubberFill = document.getElementById('clip-scrubber-fill');

  const tlPlayer = document.getElementById('timeline-player');
  const tlPlaceholder = document.getElementById('tl-placeholder');

  const searchInput = document.getElementById('search-input');
  const mediaGrid = document.getElementById('media-grid');

  const btnPlay = document.getElementById('btn-play');
  const playIcon = document.getElementById('play-icon');
  const btnBack = document.getElementById('btn-back');
  const btnFwd = document.getElementById('btn-fwd');

  const ruler = document.getElementById('ruler');
  const rulerCanvas = document.getElementById('ruler-canvas');
  const playhead = document.getElementById('playhead');
  const tracksContainer = document.getElementById('tracks-container');
  const addTrackBtn = document.getElementById('add-track-btn');
  const ctx = rulerCanvas.getContext('2d');

  function getAllTracks() {
    return document.querySelectorAll('.track');
  }

  let trackCount = 0;

  const CLIP_COLORS = [
    '#6c5ce7','#e84393','#00b894','#fdcb6e','#e17055',
    '#0984e3','#00cec9','#d63031','#a29bfe','#55efc4'
  ];
  let colorIndex = 0;

  let timelineDuration = 60;
  let timelineClips = [];
  let isTimelinePlaying = false;
  let timelinePlayTime = 0;
  let lastFrameTime = 0;
  let activeClipForPlayback = null;
  let pendingSeekClip = null;
  let tlCurrentSrc = '';
  let selectedClipIds = new Set();

  // ── Undo history ──
  const undoStack = [];
  const MAX_UNDO = 50;

  function pushUndo() {
    undoStack.push(JSON.stringify(timelineClips));
    if (undoStack.length > MAX_UNDO) undoStack.shift();
  }

  function undo() {
    if (undoStack.length === 0) return;
    timelineClips = JSON.parse(undoStack.pop());
    selectedClipIds.clear();
    recalcTimelineDuration();
    renderClips();
    drawRuler();
    syncTimelinePreview();
  }

  // ── Search ──
  searchInput.addEventListener('input', () => {
    const query = searchInput.value.trim().toLowerCase();
    document.querySelectorAll('#media-grid .card').forEach(card => {
      const label = (card.dataset.label || '').toLowerCase();
      card.classList.toggle('hidden', query !== '' && !label.includes(query));
    });
  });

  searchInput.addEventListener('keydown', (e) => {
    e.stopPropagation();
  });

  // ── Track management ──
  function createTrack() {
    const idx = trackCount++;
    const track = document.createElement('div');
    track.className = 'track';
    track.dataset.track = idx;

    const btn = document.createElement('button');
    btn.className = 'track-remove';
    btn.innerHTML = '&minus;';
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeTrack(idx);
    });
    track.appendChild(btn);
    tracksContainer.appendChild(track);
    updateTrackButtons();
    return track;
  }

  function removeTrack(idx) {
    if (getAllTracks().length <= 1) return;
    const hasClips = timelineClips.some(c => c.track === idx);
    if (hasClips) return;
    const track = document.querySelector(`.track[data-track="${idx}"]`);
    if (track) track.remove();
    updateTrackButtons();
  }

  function updateTrackButtons() {
    const tracks = getAllTracks();
    tracks.forEach(track => {
      const idx = parseInt(track.dataset.track);
      const hasClips = timelineClips.some(c => c.track === idx);
      const btn = track.querySelector('.track-remove');
      if (btn) {
        btn.style.display = (!hasClips && tracks.length > 1) ? 'flex' : 'none';
      }
    });
  }

  // Create initial tracks
  createTrack();
  createTrack();
  createTrack();

  addTrackBtn.addEventListener('click', () => {
    createTrack();
  });

  // ── Clip preview: scrub on video ──
  clipPreviewContainer.addEventListener('mousedown', (e) => {
    if (clipPlayer.style.display === 'none') return;
    if (!clipPlayer.duration) return;
    e.preventDefault();
    const startX = e.clientX;
    let scrubbing = false;

    function onMove(e2) {
      if (!scrubbing && Math.abs(e2.clientX - startX) > 3) {
        scrubbing = true;
        clipPlayer.pause();
      }
      if (scrubbing) {
        const rect = clipPreviewContainer.getBoundingClientRect();
        const pct = Math.max(0, Math.min(1, (e2.clientX - rect.left) / rect.width));
        clipPlayer.currentTime = pct * clipPlayer.duration;
        clipScrubberFill.style.width = (pct * 100) + '%';
      }
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      if (!scrubbing) {
        if (clipPlayer.paused) clipPlayer.play();
        else clipPlayer.pause();
      }
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  // ── Clip scrubber bar ──
  clipScrubber.addEventListener('mousedown', (e) => {
    seekClipScrubber(e);
    function onMove(e2) { seekClipScrubber(e2); }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  function seekClipScrubber(e) {
    if (!clipPlayer.duration) return;
    const rect = clipScrubber.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    clipPlayer.currentTime = pct * clipPlayer.duration;
    clipScrubberFill.style.width = (pct * 100) + '%';
  }

  clipPlayer.addEventListener('timeupdate', () => {
    if (clipPlayer.duration) {
      clipScrubberFill.style.width = (clipPlayer.currentTime / clipPlayer.duration * 100) + '%';
    }
  });

  clipPlayer.addEventListener('ended', () => {
    clipScrubberFill.style.width = '100%';
  });

  // ── Thumbnail generation ──
  function generateThumbnail(card) {
    const src = card.dataset.src;
    const canvas = card.querySelector('.card-thumb');
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.muted = true;
    video.src = src;

    video.addEventListener('loadedmetadata', () => {
      const seekTo = video.duration * (0.25 + Math.random() * 0.25);
      video.currentTime = seekTo;
      card.dataset.duration = video.duration;
    });

    video.addEventListener('seeked', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const cCtx = canvas.getContext('2d');
      cCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
      video.src = '';
      video.load();
    });
  }

  // ── Card event setup ──
  function setupCardClick(card) {
    card.addEventListener('click', () => {
      document.querySelectorAll('#media-grid .card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      const src = card.dataset.src;
      clipPlaceholder.style.display = 'none';
      clipPlayer.style.display = 'block';
      clipPlayer.src = src;
      clipPlayer.play();
      clipScrubberFill.style.width = '0%';
    });
  }

  function setupCardDrag(card) {
    card.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      const startX = e.clientX;
      const startY = e.clientY;
      let dragging = false;
      let dragGhost = null;
      let dragData = null;

      function onMove(e2) {
        const dx = e2.clientX - startX;
        const dy = e2.clientY - startY;
        if (!dragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
          dragging = true;
          dragData = {
            src: card.dataset.src,
            label: card.dataset.label,
            duration: parseFloat(card.dataset.duration) || 30
          };
          dragGhost = document.createElement('div');
          dragGhost.className = 'drag-ghost';
          dragGhost.textContent = dragData.label;
          document.body.appendChild(dragGhost);
        }
        if (dragging && dragGhost) {
          dragGhost.style.left = e2.clientX + 12 + 'px';
          dragGhost.style.top = e2.clientY - 16 + 'px';
          getAllTracks().forEach(t => t.classList.remove('drag-over'));
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          if (el && el.closest('.track')) {
            el.closest('.track').classList.add('drag-over');
          }
        }
      }

      function onUp(e2) {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        if (dragGhost) {
          dragGhost.remove();
          dragGhost = null;
        }
        getAllTracks().forEach(t => t.classList.remove('drag-over'));
        if (dragging && dragData) {
          const el = document.elementFromPoint(e2.clientX, e2.clientY);
          const track = el && el.closest('.track');
          if (track) {
            const trackIdx = parseInt(track.dataset.track);
            const rect = track.getBoundingClientRect();
            const dropPct = (e2.clientX - rect.left) / rect.width;
            const dropTime = dropPct * timelineDuration;
            const clipDur = Math.min(dragData.duration, timelineDuration - dropTime);
            if (clipDur > 1) {
              addClip(trackIdx, dropTime, clipDur, dragData.src, dragData.label, dragData.duration);
            }
          }
        }
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // ── Media library ──
  // Fallback list — used when directory listing is unavailable (e.g. file:// protocol).
  // Update this array if you add/remove files and aren't using a web server.
  const FALLBACK_FILES = [
    '40k end up in morgues.mp4',
    'a_bomb.mp4',
    'come stay in this hotel.mp4',
    'enemy would like.mp4',
    'lesbian implications.mp4',
    'psychiatrists believe.mp4',
    'sign of a poorly-balanced economy.mp4',
    'through the mouth and nose.mp4',
    'traffic signs.mp4',
    'where does pollution come from.mp4'
  ];

  async function scanAssetsDirectory() {
    try {
      const resp = await fetch('assets/');
      if (!resp.ok) return [];
      const html = await resp.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const links = doc.querySelectorAll('a');
      const files = [];
      links.forEach(link => {
        const href = link.getAttribute('href');
        if (href && /\.mp4$/i.test(href)) {
          const rawHref = href.split('/').pop();
          const decoded = decodeURIComponent(rawHref);
          const name = decoded.replace(/\.mp4$/i, '');
          const label = name.replace(/[_-]/g, ' ').toUpperCase();
          files.push({ src: 'assets/' + rawHref, label: label });
        }
      });
      return files;
    } catch(e) {
      return [];
    }
  }

  function buildFileList(filenames) {
    return filenames.map(f => {
      const name = f.replace(/\.mp4$/i, '');
      const label = name.replace(/[_-]/g, ' ').toUpperCase();
      return { src: 'assets/' + encodeURIComponent(f), label: label };
    });
  }

  function addCardToGrid(f) {
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.src = f.src;
    card.dataset.label = f.label;

    const canvas = document.createElement('canvas');
    canvas.className = 'card-thumb';
    card.appendChild(canvas);

    const labelDiv = document.createElement('div');
    labelDiv.className = 'card-label';
    labelDiv.textContent = f.label;
    card.appendChild(labelDiv);

    mediaGrid.appendChild(card);
    generateThumbnail(card);
    setupCardClick(card);
    setupCardDrag(card);
  }

  async function loadMediaLibrary() {
    let files = await scanAssetsDirectory();
    if (files.length === 0) {
      files = buildFileList(FALLBACK_FILES);
    }
    files.sort((a, b) => a.label.localeCompare(b.label));
    files.forEach(f => addCardToGrid(f));
  }

  // ── Clip management ──
  function addClip(trackIdx, startTime, clipDur, src, label, srcDuration) {
    pushUndo();
    const clip = {
      id: Date.now() + Math.random(),
      track: trackIdx,
      start: Math.max(0, startTime),
      duration: clipDur,
      src: src,
      label: label,
      srcDuration: srcDuration,
      srcOffset: 0,
      color: CLIP_COLORS[colorIndex % CLIP_COLORS.length]
    };
    colorIndex++;
    timelineClips.push(clip);
    recalcTimelineDuration();
    renderClips();
    drawRuler();
    syncTimelinePreview();
  }

  function recalcTimelineDuration() {
    let maxEnd = 60;
    timelineClips.forEach(c => {
      const end = c.start + c.duration;
      if (end > maxEnd - 10) maxEnd = end + 30;
    });
    timelineDuration = maxEnd;
  }

  function renderClips() {
    document.querySelectorAll('.clip').forEach(el => el.remove());

    timelineClips.forEach(clip => {
      const track = document.querySelector(`.track[data-track="${clip.track}"]`);
      if (!track) return;

      const el = document.createElement('div');
      el.className = 'clip' + (selectedClipIds.has(clip.id) ? ' selected' : '');
      el.dataset.clipId = clip.id;
      el.style.background = clip.color;
      el.style.left = (clip.start / timelineDuration * 100) + '%';
      el.style.width = (clip.duration / timelineDuration * 100) + '%';

      const handleL = document.createElement('div');
      handleL.className = 'clip-handle left';
      const handleR = document.createElement('div');
      handleR.className = 'clip-handle right';

      const labelEl = document.createElement('span');
      labelEl.className = 'clip-label';
      labelEl.textContent = clip.label;

      el.appendChild(handleL);
      el.appendChild(labelEl);
      el.appendChild(handleR);
      track.appendChild(el);

      el.addEventListener('click', (e) => {
        e.stopPropagation();
        if (e.shiftKey || e.metaKey || e.ctrlKey) {
          if (selectedClipIds.has(clip.id)) selectedClipIds.delete(clip.id);
          else selectedClipIds.add(clip.id);
        } else {
          if (selectedClipIds.has(clip.id) && selectedClipIds.size === 1) {
            selectedClipIds.clear();
          } else {
            selectedClipIds.clear();
            selectedClipIds.add(clip.id);
          }
        }
        renderClips();
      });

      setupClipDrag(el, clip);
      setupClipResize(handleL, clip, 'left');
      setupClipResize(handleR, clip, 'right');
    });

    updateTrackButtons();
  }

  function setupClipDrag(el, clip) {
    el.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('clip-handle')) return;
      e.stopPropagation();
      e.preventDefault();
      const startX = e.clientX;
      const origStart = clip.start;
      let pushed = false;

      function onMove(e2) {
        if (!pushed) { pushUndo(); pushed = true; }
        const rulerRect = ruler.getBoundingClientRect();
        const dx = e2.clientX - startX;
        const dtSec = (dx / rulerRect.width) * timelineDuration;
        clip.start = Math.max(0, Math.min(timelineDuration - clip.duration, origStart + dtSec));

        const trackEl = document.elementFromPoint(e2.clientX, e2.clientY);
        const newTrack = trackEl && trackEl.closest('.track');
        if (newTrack) {
          clip.track = parseInt(newTrack.dataset.track);
        }

        renderClips();
      }

      function onUp() {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  function setupClipResize(handle, clip, side) {
    handle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      pushUndo();
      const startX = e.clientX;
      const origStart = clip.start;
      const origDur = clip.duration;
      const origOffset = clip.srcOffset;
      handle.classList.add('dragging');

      function onMove(e2) {
        const rulerRect = ruler.getBoundingClientRect();
        const dx = e2.clientX - startX;
        const dtSec = (dx / rulerRect.width) * timelineDuration;

        if (side === 'left') {
          const newStart = Math.max(0, origStart + dtSec);
          const delta = newStart - origStart;
          const newDur = origDur - delta;
          if (newDur > 1) {
            clip.start = newStart;
            clip.duration = newDur;
            clip.srcOffset = Math.max(0, origOffset + delta);
          }
        } else {
          const newDur = Math.max(1, origDur + dtSec);
          const maxDur = clip.srcDuration - clip.srcOffset;
          clip.duration = Math.min(newDur, maxDur, timelineDuration - clip.start);
        }

        recalcTimelineDuration();
        renderClips();
        drawRuler();
      }

      function onUp() {
        handle.classList.remove('dragging');
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // ── Timeline preview sync ──
  function syncTimelinePreview() {
    const clip = getClipAtTime(timelinePlayTime);

    if (clip) {
      tlPlaceholder.style.display = 'none';
      tlPlayer.style.display = 'block';
      const targetTime = clip.srcOffset + (timelinePlayTime - clip.start);

      if (tlCurrentSrc === clip.src) {
        tlPlayer.currentTime = targetTime;
        if (isTimelinePlaying && tlPlayer.paused) tlPlayer.play();
        activeClipForPlayback = clip;
      } else {
        tlPlayer.pause();
        pendingSeekClip = clip;
        tlCurrentSrc = clip.src;
        tlPlayer.src = clip.src;
        tlPlayer.load();
        activeClipForPlayback = clip;
      }
    } else {
      tlPlayer.pause();
      activeClipForPlayback = null;
    }
  }

  tlPlayer.addEventListener('loadeddata', () => {
    if (pendingSeekClip) {
      const clip = pendingSeekClip;
      pendingSeekClip = null;
      const targetTime = clip.srcOffset + (timelinePlayTime - clip.start);
      tlPlayer.currentTime = Math.max(0, targetTime);
      if (isTimelinePlaying) {
        tlPlayer.play();
      }
    }
  });

  // ── Play/pause icon helpers ──
  function setPlayIcon(showPlay) {
    if (showPlay) {
      playIcon.innerHTML = '<polygon points="8,4 8,32 30,18" fill="#ccc"/>';
    } else {
      playIcon.innerHTML = '<rect x="7" y="5" width="7" height="26" rx="1" fill="#ccc"/><rect x="22" y="5" width="7" height="26" rx="1" fill="#ccc"/>';
    }
  }

  // ── Playback controls (timeline only) ──
  btnPlay.addEventListener('click', () => {
    toggleTimelinePlayback();
  });

  btnBack.addEventListener('click', () => {
    timelinePlayTime = Math.max(0, timelinePlayTime - 5);
    updatePlayhead();
    syncTimelinePreview();
  });

  btnFwd.addEventListener('click', () => {
    timelinePlayTime = Math.min(timelineDuration, timelinePlayTime + 5);
    updatePlayhead();
    syncTimelinePreview();
  });

  // ── Timeline playback ──
  function toggleTimelinePlayback() {
    if (isTimelinePlaying) {
      stopTimelinePlayback();
    } else {
      startTimelinePlayback();
    }
  }

  function startTimelinePlayback() {
    if (timelineClips.length === 0) return;
    isTimelinePlaying = true;
    setPlayIcon(false);
    lastFrameTime = performance.now();
    syncTimelinePreview();
    requestAnimationFrame(timelineTick);
  }

  function stopTimelinePlayback() {
    isTimelinePlaying = false;
    setPlayIcon(true);
    tlPlayer.pause();
    activeClipForPlayback = null;
  }

  function getClipAtTime(t) {
    let best = null;
    for (const clip of timelineClips) {
      if (t >= clip.start && t < clip.start + clip.duration) {
        if (!best || clip.track < best.track) {
          best = clip;
        }
      }
    }
    return best;
  }

  function timelineTick(now) {
    if (!isTimelinePlaying) return;
    const dt = (now - lastFrameTime) / 1000;
    lastFrameTime = now;
    timelinePlayTime += dt;

    if (timelinePlayTime >= timelineDuration) {
      timelinePlayTime = 0;
      stopTimelinePlayback();
      updatePlayhead();
      return;
    }

    updatePlayhead();

    const clip = getClipAtTime(timelinePlayTime);
    if (clip !== activeClipForPlayback) {
      syncTimelinePreview();
    }

    requestAnimationFrame(timelineTick);
  }

  // ── Ruler drawing ──
  function drawRuler() {
    const dpr = window.devicePixelRatio || 1;
    const rect = rulerCanvas.getBoundingClientRect();
    rulerCanvas.width = rect.width * dpr;
    rulerCanvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, rect.width, rect.height);

    const dur = timelineDuration;
    if (!dur) return;

    const interval = getTickInterval(dur, rect.width);
    const totalTicks = Math.floor(dur / interval);

    for (let i = 0; i <= totalTicks; i++) {
      const time = i * interval;
      const x = (time / dur) * rect.width;
      const isMajor = (i % 5 === 0);

      ctx.beginPath();
      ctx.moveTo(x, isMajor ? 4 : 12);
      ctx.lineTo(x, rect.height);
      ctx.strokeStyle = isMajor ? '#333' : '#222';
      ctx.lineWidth = 1;
      ctx.stroke();

      if (isMajor) {
        ctx.fillStyle = '#555';
        ctx.font = '9px IBM Plex Mono';
        ctx.fillText(formatTime(time), x + 3, 12);
      }
    }
  }

  function getTickInterval(duration, width) {
    const targetPx = 40;
    const approxTicks = width / targetPx;
    const rawInterval = duration / approxTicks;
    const steps = [1, 2, 5, 10, 15, 30, 60, 120, 300, 600];
    for (const s of steps) {
      if (s >= rawInterval) return s;
    }
    return 600;
  }

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return m + ':' + String(s).padStart(2, '0');
  }

  function updatePlayhead() {
    const pct = (timelinePlayTime / timelineDuration) * 100;
    playhead.style.left = pct + '%';
  }

  // ── Ruler scrub (click + drag) ──
  ruler.addEventListener('mousedown', (e) => {
    seekRuler(e);
    function onMove(e2) { seekRuler(e2); }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  function seekRuler(e) {
    const rect = ruler.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    timelinePlayTime = pct * timelineDuration;
    updatePlayhead();
    syncTimelinePreview();
  }

  // ── Click empty area to deselect clips ──
  tracksContainer.addEventListener('click', () => {
    if (selectedClipIds.size > 0) {
      selectedClipIds.clear();
      renderClips();
    }
  });

  // ── Keyboard shortcuts ──
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      btnPlay.click();
    }
    if ((e.code === 'Backspace' || e.code === 'Delete') && selectedClipIds.size > 0) {
      e.preventDefault();
      pushUndo();
      timelineClips = timelineClips.filter(c => !selectedClipIds.has(c.id));
      selectedClipIds.clear();
      recalcTimelineDuration();
      renderClips();
      drawRuler();
      syncTimelinePreview();
    }
    if (e.code === 'KeyZ' && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
      e.preventDefault();
      undo();
    }
  });

  // ── Init ──
  updatePlayhead();
  loadMediaLibrary();

  // Wait for IBM Plex Mono to load before drawing ruler (canvas needs the font ready)
  document.fonts.ready.then(() => {
    drawRuler();
  });

  window.addEventListener('resize', () => {
    drawRuler();
    renderClips();
  });
</script>
</body>
</html>
